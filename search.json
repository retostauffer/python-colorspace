[
  {
    "objectID": "api.html",
    "href": "api.html",
    "title": "API Reference",
    "section": "",
    "text": "hcl_palettes\nPre-Defined HCL Palettes\n\n\nqualitative_hcl\nQualitative HCL Color Palettes\n\n\nsequential_hcl\nSequential HCL Color Palettes\n\n\ndiverging_hcl\nDiverging HCL Color Palettes\n\n\nrainbow_hcl\nHCL Based Rainbow Palette\n\n\nheat_hcl\nHCL Based Heat Color Palette\n\n\nterrain_hcl\nHCL Based Terrain Color Palette\n\n\ndiverging_hsv\nDiverging HCL Color Palettes\n\n\nrainbow\nInfamous sRGB Rainbow Color Palette\n\n\npalette\nCustom Color Palette"
  },
  {
    "objectID": "api.html#color-palettes",
    "href": "api.html#color-palettes",
    "title": "API Reference",
    "section": "",
    "text": "hcl_palettes\nPre-Defined HCL Palettes\n\n\nqualitative_hcl\nQualitative HCL Color Palettes\n\n\nsequential_hcl\nSequential HCL Color Palettes\n\n\ndiverging_hcl\nDiverging HCL Color Palettes\n\n\nrainbow_hcl\nHCL Based Rainbow Palette\n\n\nheat_hcl\nHCL Based Heat Color Palette\n\n\nterrain_hcl\nHCL Based Terrain Color Palette\n\n\ndiverging_hsv\nDiverging HCL Color Palettes\n\n\nrainbow\nInfamous sRGB Rainbow Color Palette\n\n\npalette\nCustom Color Palette"
  },
  {
    "objectID": "api.html#gui-for-choosing-color-palettes",
    "href": "api.html#gui-for-choosing-color-palettes",
    "title": "API Reference",
    "section": "GUI for choosing color palettes",
    "text": "GUI for choosing color palettes\n\n\n\n\n\n\n\n\nchoose_palette\nGraphical User Interface for Choosing HCL Color Palettes"
  },
  {
    "objectID": "api.html#assessing-colors-and-palettes",
    "href": "api.html#assessing-colors-and-palettes",
    "title": "API Reference",
    "section": "Assessing colors and palettes",
    "text": "Assessing colors and palettes\n\n\n\n\n\n\n\n\nspecplot\nColor Spectrum Plot\n\n\nswatchplot\nPalette Swatch Plot\n\n\ndemoplot\nCreate Demo Plots"
  },
  {
    "objectID": "api.html#color-vision-defficiency",
    "href": "api.html#color-vision-defficiency",
    "title": "API Reference",
    "section": "Color vision defficiency",
    "text": "Color vision defficiency\n\n\n\n\n\n\n\n\ndesaturate\nDesaturate Colors by Chroma Removal in HCL Space\n\n\ndeutan, protan, tritan\nSimulate Color Vision Deficiency\n\n\ncvd_emulator\nCheck Images for Color Constraints"
  },
  {
    "objectID": "api.html#color-manipulation",
    "href": "api.html#color-manipulation",
    "title": "API Reference",
    "section": "Color manipulation",
    "text": "Color manipulation\n\n\n\n\n\n\n\n\nmax_chroma\nCompute Maximum Chroma for Given Hue and Luminance in HCL\n\n\ncontrast_ratio\nW3C Contrast Ratio\n\n\ncompare_colors\nCompare colors/check for equality\n\n\ncheck_hex_colors\nChecking HEX Color Validity\n\n\nlighten, darken\nAlgorithmically Lighten or Darken Colors\n\n\nmixcolor\nCompute the Convex Combination of Two Colors\n\n\nextract_transparency, adjust_transparency\nAdjust or Extract Transparency of Colors"
  },
  {
    "objectID": "api.html#color-librarycolor-transformations",
    "href": "api.html#color-librarycolor-transformations",
    "title": "API Reference",
    "section": "Color library/color transformations",
    "text": "Color library/color transformations\n\n\n\n\n\n\n\n\npolarLUV\nCreate polarLUV (HCL) Colors\n\n\nCIELUV\nCreate CIELUV Colors\n\n\npolarLAB\nCreate polarLAB Colors\n\n\nCIELAB\nCreate CIELAB Colors\n\n\nCIEXYZ\nCreate CIEXYZ Colors\n\n\nRGB\nCreate RGB Colors\n\n\nsRGB\nCreate sRGB (standard RGB) Colors\n\n\nHSV\nCreate Hue-Saturation-Value (HSV) Colors\n\n\nHLS\nCreate Hue-Lightness-Saturation (HLS) Colors\n\n\nhexcols\nCreate HEX Colors\n\n\ncolorlib\nColor Handling Superclass"
  },
  {
    "objectID": "articles/choose_palette.html",
    "href": "articles/choose_palette.html",
    "title": "Apps for Choosing Colors and Palettes Interactively",
    "section": "",
    "text": "To facilitate exploring the package and employing it when working with colors, a Tcl/Tk based is provided within the package using Pythons tkinter interface.\nfrom colorspace import choose_palette\nchoose_palette()"
  },
  {
    "objectID": "articles/choose_palette.html#web-app",
    "href": "articles/choose_palette.html#web-app",
    "title": "Apps for Choosing Colors and Palettes Interactively",
    "section": "Web App",
    "text": "Web App\nA web-app to explore the capabilities based on the R implementation colorspace is available via https://hclwizard.org.\n\nPalette Creator\nDeficiency Emulator\nColor Picker\n\nThe latter two do not exist as GUIs in the Python implementation, however, the function cvd_emulator allows to emulate color vision deficiencies from within the Python package. For more information please have a look at the article Color Vision Deficiency Emulation."
  },
  {
    "objectID": "articles/cvd.html",
    "href": "articles/cvd.html",
    "title": "Color Vision Deficiency Emulation",
    "section": "",
    "text": "Different kinds of limitations can be emulated using the physiologically-based model for simulating color vision deficiency (CVD) of Machado, Oliveira, and Fernandes (2009)` deuteranomaly (green cone cells defective), protanomaly (red cone cells defective), and tritanomaly (blue cone cells defective). While most other CVD simulations handle only dichromacy, where one of three cones is non-functional, Machado, Oliveira, and Fernandes (2009) provides a unified model of both dichromacy and anomalous trichromacy, where one cone has shifted spectral sensitivity. As anomalous trichromacy is the most common form of color vision deficiency, it is important to emulate along with the rarer, but more severe dichromacy.\nThe workhorse function to emulate color vision deficiencies is simulate_cvd(), which can take any vector of valid R colors and transform them according to a certain CVD transformation matrix and transformation equation. The transformation matrices have been established by Machado, Oliveira, and Fernandes (2009) and are provided by methods of class CVD. The convenience interfaces deutan, protan, tritan, are the high-level functions for simulating the corresponding kind of color blindness with a given severity. A severity of 1 corresponds to dichromacy, 0 to normal color vision, and intermediate values to varying severities of anomalous trichromacy.\nFor further guidance on color blindness in relation to statistical graphics see Lumley (2013) which accompanies the R package dichromat (Lumley 2013) and is based on earlier emulation techniques Viénot, Brettel, and Mollon (1999)."
  },
  {
    "objectID": "articles/cvd.html#overview",
    "href": "articles/cvd.html#overview",
    "title": "Color Vision Deficiency Emulation",
    "section": "",
    "text": "Different kinds of limitations can be emulated using the physiologically-based model for simulating color vision deficiency (CVD) of Machado, Oliveira, and Fernandes (2009)` deuteranomaly (green cone cells defective), protanomaly (red cone cells defective), and tritanomaly (blue cone cells defective). While most other CVD simulations handle only dichromacy, where one of three cones is non-functional, Machado, Oliveira, and Fernandes (2009) provides a unified model of both dichromacy and anomalous trichromacy, where one cone has shifted spectral sensitivity. As anomalous trichromacy is the most common form of color vision deficiency, it is important to emulate along with the rarer, but more severe dichromacy.\nThe workhorse function to emulate color vision deficiencies is simulate_cvd(), which can take any vector of valid R colors and transform them according to a certain CVD transformation matrix and transformation equation. The transformation matrices have been established by Machado, Oliveira, and Fernandes (2009) and are provided by methods of class CVD. The convenience interfaces deutan, protan, tritan, are the high-level functions for simulating the corresponding kind of color blindness with a given severity. A severity of 1 corresponds to dichromacy, 0 to normal color vision, and intermediate values to varying severities of anomalous trichromacy.\nFor further guidance on color blindness in relation to statistical graphics see Lumley (2013) which accompanies the R package dichromat (Lumley 2013) and is based on earlier emulation techniques Viénot, Brettel, and Mollon (1999)."
  },
  {
    "objectID": "articles/cvd.html#illustration-heatmap-with-sequential-palette",
    "href": "articles/cvd.html#illustration-heatmap-with-sequential-palette",
    "title": "Color Vision Deficiency Emulation",
    "section": "Illustration: Heatmap with sequential palette",
    "text": "Illustration: Heatmap with sequential palette\nTo illustrate that poor color choices can severely reduce the usefulness of a statistical graphic for readers with color vision deficiencies, we employ the infamous RGB rainbow color palette in a heatmap. In base R this can be generated by `rainbow(end = 2/3, rev = True)(7) ranging from red (for high values) to blue (for low values).\nThe poor results for the RGB rainbow palette are contrasted with a proper sequential palette ranging from dark blue to light yellow: `sequential_hcl(“Blue-Yellow”)(7).\nThe statistical graphic employed for illustration is a heatmap of the well-known Maunga Whau volcano data from base R. This heatmap is easily available as demoplot(x, \"Heatmap\") where x is the color vector to be used, e.g.,\nfrom colorspace import rainbow, deutan\n\nprint(rainbow(end = 2/3, rev = True)(7))\nprint(deutan(rainbow(end = 2/3, rev = True)(7)))\n\n\n\n['#0000FF', '#00AAFF', '#00FFAA', '#00FF00', '#AAFF00', '#FFAA00', '#FF0000']\n['#003DFB', '#6099FD', '#E3D9B0', '#EFD63A', '#FFE537', '#DCC411', '#A39000']\n\n\n\nand so on. To aid the interpretation of the heatmap a perspective display using only gray shades is included first, providing another intuitive display of what the terrain around Maunga Whau looks like.\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LightSource\n \nfrom colorspace import sequential_hcl\nfrom colorspace.demos import get_volcano_data\n \n# Color palette to use (grayscale)\npal  = sequential_hcl(c1 = 0, c2 = 0)\n \n# Loading vulcano\ndata = get_volcano_data(True)\nY    = np.linspace(1, data.shape[0], data.shape[0])\nX    = np.linspace(1, data.shape[1], data.shape[1])\nX, Y = np.meshgrid(X, Y)\n \nfig, ax = plt.subplots(subplot_kw ={\"projection\": \"3d\"}, figsize = (10, 6))\n\nax.set_axis_off() \nax.set_box_aspect(aspect = (data.shape[1], data.shape[0], data.shape[0] / 3)) \nfig.subplots_adjust(left = 0, right = 1, bottom = -.4, top = 1.6) \n \n# Create/calculate facing colors using custom shading\nls      = LightSource(270, 45)\nfcolors = ls.shade(data, cmap = pal.cmap(), vert_exag=0.1, blend_mode='soft')\n \nsurf = ax.plot_surface(X, Y, data, rstride = 1, cstride = 1, facecolors = fcolors,\n                       linewidth = 0, antialiased = False, shade = False)\n \nplt.show()\n\n\n\n\n\n\n\nSubsequently, all combinations of palette and color vision deficiency are visualized. Additionally, a grayscale version is created with desaturate.\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, sequential_hcl, rainbow\nfrom colorspace import desaturate, protan, deutan, tritan \n\n# Picking 7 colors from two different color palettes\ncol_rainbow = rainbow(end = 2/3, rev = True)(7)\ncol_hcl     = sequential_hcl(\"Blue-Yellow\", rev = True)(7)\n\nfig, axes = plt.subplots(5, 2, figsize = (9, 13))\n\ndemoplot(col_rainbow, type_ = \"Heatmap\", ax = axes[0, 0], ylabel = \"Original\",\n         title = \"rainbow(end = 2/3, rev = True)(7)\")\ndemoplot(col_hcl,     type_ = \"Heatmap\", ax = axes[0, 1], ylabel = \"Original\",\n         title = \"sequential_hcl(\\\"Blue-Yellow\\\", rev = True)(7)\")\n\ndemoplot(desaturate(col_rainbow), type_ = \"Heatmap\", ax = axes[1, 0], ylabel = \"Desaturated\")\ndemoplot(desaturate(col_hcl),     type_ = \"Heatmap\", ax = axes[1, 1], ylabel = \"Desaturated\")\n\ndemoplot(deutan(col_rainbow),     type_ = \"Heatmap\", ax = axes[2, 0], ylabel = \"Deuteranope\")\ndemoplot(deutan(col_hcl),         type_ = \"Heatmap\", ax = axes[2, 1], ylabel = \"Deuteranope\")\n\ndemoplot(protan(col_rainbow),     type_ = \"Heatmap\", ax = axes[3, 0], ylabel = \"Protanope\")\ndemoplot(protan(col_hcl),         type_ = \"Heatmap\", ax = axes[3, 1], ylabel = \"Protanope\")\n\ndemoplot(tritan(col_rainbow),     type_ = \"Heatmap\", ax = axes[4, 0], ylabel = \"Tritanope\")\ndemoplot(tritan(col_hcl),         type_ = \"Heatmap\", ax = axes[4, 1], ylabel = \"Tritanope\")\n\nplt.show()\n\n\n\n\n\n\n\nThis clearly shows how poorly the RGB rainbow performs, often giving quite misleading impressions of the terrain around Maunga Whau. In contrast, the HCL-based blue-yellow palette works reasonably well in all settings. The most important problem of the RGB rainbow is that it is not monotonic in luminance, making correct interpretation quite hard. Moreover, the red-green contrasts deteriorate substantially in the dichromatic emulations."
  },
  {
    "objectID": "articles/cvd.html#illustration-map-with-diverging-palette",
    "href": "articles/cvd.html#illustration-map-with-diverging-palette",
    "title": "Color Vision Deficiency Emulation",
    "section": "Illustration: Map with diverging palette",
    "text": "Illustration: Map with diverging palette\nAs another example for the poor performance of the RGB rainbow we employ a shaded map. This is available as demoplot(x, \"Map\") and is based on county polygons for Alabama, Georgia, and South Carolina along with an artifical variable used for coloring.\nOften the red-yellow-green RGB spectrum is used for a diverging palette with yellow as the neutral value. This can easily be generated using rainbow(end = 1/3)(11). However, this palette has again a number of weaknesses, especially that the green-yellow part of the palette almost collapses to the same color when desaturated or when color blindness is emulated.\nTo illustrate that much more balanced palettes for the same purpose are available the Geyser palette (mimicked from CARTO 2019) is adopted: divergingx_hcl(\"Geyser\"\")(11)\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, divergingx_hcl, rainbow\nfrom colorspace import desaturate, protan, deutan, tritan\n\nfig, axes = plt.subplots(5, 2, figsize = (9, 13))\n\n# Picking 11 colors from two different color palettes\ncol_rainbow = rainbow(end = 1/3)(11)\ncol_hcl     = divergingx_hcl(\"Geyser\")(11)\n\ndemoplot(col_rainbow, type_ = \"Map\", ax = axes[0, 0], ylabel = \"Original\",\n         title = \"rainbow(end = 1/3)(11)\")\ndemoplot(col_hcl,     type_ = \"Map\", ax = axes[0, 1], ylabel = \"Original\",\n         title = \"divergingx_hcl(\\\"Geyser\\\")(11)\")\n\ndemoplot(desaturate(col_rainbow), type_ = \"Map\", ax = axes[1, 0], ylabel = \"Desaturated\")\ndemoplot(desaturate(col_hcl),     type_ = \"Map\", ax = axes[1, 1], ylabel = \"Desaturated\")\n\ndemoplot(deutan(col_rainbow),     type_ = \"Map\", ax = axes[2, 0], ylabel = \"Deuteranope\")\ndemoplot(deutan(col_hcl),         type_ = \"Map\", ax = axes[2, 1], ylabel = \"Deuteranope\")\n\ndemoplot(protan(col_rainbow),     type_ = \"Map\", ax = axes[3, 0], ylabel = \"Protanope\")\ndemoplot(protan(col_hcl),         type_ = \"Map\", ax = axes[3, 1], ylabel = \"Protanope\")\n\ndemoplot(tritan(col_rainbow),     type_ = \"Map\", ax = axes[4, 0], ylabel = \"Tritanope\")\ndemoplot(tritan(col_hcl),         type_ = \"Map\", ax = axes[4, 1], ylabel = \"Tritanope\")\n\nplt.show()\n\n\n\n\n\n\n\nWhile many versions of the RGB rainbow displays are hard to read because they do not bring out any differences in the green-yellow arm of the palette, the HCL-based palette works reasonably well in all settings. Only the grayscale version cannot bring out the different arms of the palette. However, at least both directions of deviation are visible even if they cannot be distinguished. This is preferable to the RGB rainbow which hides all differences in the green-yellow arm of the palette. (However, if grayscale printing is desired a sequential rather than a diverging palette is probably necessary.)\n\nSee Color Vision Deficiency Emulation"
  },
  {
    "objectID": "articles/cvd.html#manipulating-figures",
    "href": "articles/cvd.html#manipulating-figures",
    "title": "Color Vision Deficiency Emulation",
    "section": "Manipulating figures",
    "text": "Manipulating figures\nIn addition of converting colors and palettes the function cvd_emulator allows to take an existing pixel image (JPG, PNG) and emulate how people with visual constraints will receive the same picture. This requires imageio to be installed (see Installation).\nThe first argument of cvd_emulator can be a path to any pixel image on your local computer OR the string \"DEMO\". When \"DEMO\" is used a demo image included in the package will be used (thanks to @mariogogh on unsplash.com; the bird is used to show handling of transparency). The following shows the original (full color) image.\nfrom colorspace import cvd_emulator\ncvd_emulator(\"DEMO\", \"original\")\n\n\n\n\n\n\n\n\n\n\n\ncvd_emulator allows simulate deuteranope, protanope, tritanope, and desaturated versions with different severities (defaults to severity = 1.0). The function reads the RGB(+alpha) coordinates of the pixel image, creates an sRGB object, and calls the requested functions (deutan, protan, tritan, and desaturate) before re-creating the image.\nfrom colorspace import cvd_emulator\ncvd_emulator(\"DEMO\", [\"deutan\", \"protan\", \"tritan\", \"desaturate\"])\n\n\n\n\n\n\n\n\n\n\n\nThe additional argument output (path to file) can be used to store the result rather than displaying it."
  },
  {
    "objectID": "articles/approximations.html",
    "href": "articles/approximations.html",
    "title": "Approximating Palettes from Other Packages",
    "section": "",
    "text": "Overview\nThe flexible specification of HCL-based color palettes in colorspace allows one to closely approximate color palettes from various other packages:\n\n(Harrower and Brewer 2003) as provided by different Python packages such as colormaps, brewer2mpl (2014, no longer maintained), colorbrewer (2018), and others.\n(CARTO 2019) as provided by e.g., colormaps.\nThe viridis palettes of Smith and Van der Walt (2015) developed for matplotlib.\nThe scientific color maps of Crameri (2018).\n\nSee the discussion of HCL-based palettes for more details. In the following sections specplot is used to compare the HCL spectrum of the original palettes (top swatches, solid lines) and their HCL-based approximations (bottom swatches, dashed lines).\nBefore, a selection of such approximations using specplot is highlighted and discussed in some more detail. Specifically, the graphic below shows two blue/green/yellow palettes (colormaps.ylgnbu and matplotlib.cm.viridis) and two purple/red/yellow palettes (colormaps.sunset and matplotlib.cm.plasma). Each panel compares the hue, chroma, and luminance trajectories of the original palettes (top swatches, solid lines) and their HCL-based approximations (bottom swatches, dashed lines). The palettes are not identical but very close for most colors. Note also that the chroma trajectories from the HCL palettes (green dashed lines) have some kinks which are due to fixing HCL coordinates at the boundaries of admissible RGB colors.\nfrom colorspace import specplot, sequential_hcl\n\n# From colormaps package\nimport colormaps\nimport numpy as np\nfrom matplotlib.colors import rgb2hex\n\n# Note: There is currently a bug with `colormaps 0.4.1` in combination\n#       with `matplotlib 3.9.1`, thus the hex colors are hardcoded but\n#       based on the following command:\n# colormaps_ylgnbu = [rgb2hex(x) for x in colormaps.ylgnbu(np.linspace(1, 0, 7))]\ncolormaps_ylgnbu = [\"#081d58\", \"#253494\", \"#225ea8\", \"#41b6c4\",\n                    \"#7fcdbb\", \"#edf8b1\", \"#ffffd9\"]\n\n# Comparing against colorspace YlGnBu\nspecplot(colormaps_ylgnbu,\n         sequential_hcl(\"YlGnBu\").colors(7),\n         title = \"colormaps: ylgnbu\");\n\n\n\n\n\n\n\nfrom colorspace import specplot, sequential_hcl\n\n# Drawing colors from matplotlib color map\nimport matplotlib.cm\nfrom matplotlib.colors import rgb2hex\nimport numpy as np\n\npal = matplotlib.cm.viridis\nmpl_viridis = [rgb2hex(x) for x in pal(np.linspace(0, 1, 7))]\n\n# Comparing against matplotlib viridis color palette\nspecplot(mpl_viridis,\n         sequential_hcl(\"Viridis\").colors(7),\n         title = \"matplotlib: Viridis\");\n\n\n\n\n\n\n\nfrom colorspace import specplot, sequential_hcl\n\n# From colormaps package\nimport colormaps\nimport numpy as np\nfrom matplotlib.colors import rgb2hex\n\n# Note: There is currently a bug with `colormaps 0.4.1` in combination\n#       with `matplotlib 3.9.1`, thus the hex colors are hardcoded but\n#       based on the following command:\n# colormaps_sunset = [rgb2hex(x) for x in colormaps.sunset(np.linspace(1, 0, 7))]\ncolormaps_sunset = [\"#5c53a5\", \"#a059a0\", \"#ce6693\", \"#eb7f86\",\n                    \"#f8a07e\", \"#fac484\", \"#f3e79b\"]\n\n# Comparing against colorspace ag_Sunset\nspecplot(colormaps_sunset,\n         sequential_hcl(\"ag_Sunset\").colors(7),\n         title = \"colormaps: sunset\");\n\n\n\n\n\n\n\n\nfrom colorspace import specplot, sequential_hcl\n\n# Drawing colors from matplotlib color map\nimport matplotlib.cm\nfrom matplotlib.colors import rgb2hex\nimport numpy as np\n\npal = matplotlib.cm.plasma\nmpl_plasma = [rgb2hex(x) for x in pal(np.linspace(0, 1, 7))]\n\n# Comparing against matplotlib plasma color palette\nspecplot(mpl_plasma,\n         sequential_hcl(\"Plasma\").colors(7),\n         title = \"matplotlib: Plasma\");\n\n\n\n\n\n\n\nThese graphics illustrate what sets the viridis palettes apart from other sequential palettes. While the hue and luminance trajectories of \"Viridis\" and \"YlGnBu\" are very similar, the chroma trajectories differ: While lighter colors (with high luminance) have low chroma for “YlGnBu”, they have increasing chroma for \"Viridis\".\nSimilarly, \"ag_Sunset\" and \"Plasma\" have similar hue and luminance trajectories but different chroma trajectories. The result is that the viridis palettes have rather high chroma throughout which does not work as well for sequential palettes on a white/light background as all shaded areas convey high “intensity”. However, they work better on a dark/black background. Also, they might be a reasonable alternative for qualitative palettes when grayscale printing should also work.\n\n\n\n\n\n\nReferences\n\nCARTO. 2019. “CARTOColors – Data-Driven Color Schemes.” https://carto.com/carto-colors/.\n\n\nCrameri, Fabio. 2018. “Geodynamic Diagnostics, Scientific Visualisation and StagLab 3.0.” Geoscientific Model Development 11 (6): 2541–62. https://doi.org/10.5194/gmd-11-2541-2018.\n\n\nHarrower, Mark A., and Cynthia A. Brewer. 2003. “ColorBrewer.org: An Online Tool for Selecting Color Schemes for Maps.” The Cartographic Journal 40: 27–37. http://ColorBrewer.org/.\n\n\nSmith, Nathaniel, and Stéfan Van der Walt. 2015. “A Better Default Colormap for Matplotlib.” In SciPy 2015 – Scientific Computing with Python. Austin. https://www.youtube.com/watch?v=xAoljeRJ3lU."
  },
  {
    "objectID": "articles/color_spaces.html",
    "href": "articles/color_spaces.html",
    "title": "Color Spaces: Classes and Utilities",
    "section": "",
    "text": "At the core of the colorspace package are various utilities for computing with color spaces Wikipedia (2024c), as the name conveys. Thus, the package helps to map various three-dimensional representations of color to each other Ihaka (2003). A particularly important mapping is the one from the perceptually-based and device-independent color model HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color specifications in many systems based on the corresponding hex codes Wikipedia (2024g), e.g., in HTML but also in Python. For completeness further standard color models are included as well in the package. Their connections are illustrated in the following graph:\n\n\n\n\n\nflowchart LR\n  X[CIEXYZ]\n  PLUV((polarLUV&lt;br/&gt;HCL)) --- LUV[CIELUV] --- X\n  PLAB((polarLAB)) --- LAB[CIELAB] --- X\n  X ---|white point&lt;br&gt;= D65| RGB[RGB] ---|gamma&lt;br&gt;=2.4| sRGB[sRGB]\n  sRGB --- HSV((HSV))\n  sRGB --- hex{HEX}\n  sRGB --- HLS((HLS))\n\n\n\n\n\n\nColor models that are (or try to be) perceptually-based are displayed with circles and models that are not are displayed with rectangles. The corresponding classes in colorspace are:\n\nRGB for the classic Red-Green-Blue color model, which mixes three primary colors with different intensities to obtain a spectrum of colors. The advantage of this color model is (or was) that it corresponded to how computer and TV screens generated colors, hence it was widely adopted and still is the basis for color specifications in many systems. For example, hex color codes are employed in HTML but also in Python. However, the RGB model also has some important drawbacks: It does not take into account the output device properties, it is not perceptually uniform (a unit step within RGB does not produce a constant perceptual change in color), and it is unintuitive for humans to specify colors (say brown or pink) in this space. Wikipedia (2024c)\nsRGB addresses the issue of device dependency by adopting a so-called gamma correction. Therefore, the gamma-corrected standard RGB (sRGB), as opposed to the linearized RGB above, is a good model for specifying colors in software and for hardware. But it is still unintuitive for humans to work directly with this color space. Therefore, sRGB is a good place to end up in a color space manipulation but it is not a good place to start. Wikipedia (2024f)\nHSV is a simple transformation of the (s)RGB space that tries to capture the perceptual axes: hue (dominant wavelength, the type of color), saturation (colorfulness), and value (brightness, i.e., light vs. dark). Unfortunately, the three axes in the HSV model are confounded so that, e.g., brightness changes dramatically with hue. Wikipedia (2024g)\nHSL (Hue-Lightness-Saturation) is another transformation of (s)RGB that tries to capture the perceptual axes. It does a somewhat better job but the dimensions are still strongly confounded. Wikipedia (2024e)\nCIEXYZ was established by the CIE (Commission Internationale de l’Eclairage) based on experiments with human subjects. It provides a unique triplet of XYZ values, coding the standard observer’s perception of the color. It is device-independent but it is not perceptually uniform and the XYZ coordinates have no intuitive meaning. Wikipedia (2024a)\nCIELUV and CIELAB were therefore proposed by the CIE as perceptually uniform color spaces where the former is typically preferred for emissive technologies (such as screens and monitors) whereas the latter is usually preferred when working with dyes and pigments. The L coordinate in both spaces has the same meaning and captures luminance (light-dark contrasts). Both the U and V coordinates as well as the A and B coordinates measure positions on red/green and yellow/blue axes, respectively, albeit in somewhat different ways. While this corresponds to how human color vision likely evolved (see the next section), these two color models still not correspond to perceptual axes that humans use to describe colors. Wikipedia (2024e),Wikipedia (2024b)\npolarLUV (=HCL) and polarLAB therefore take polar coordinates in the UV plane and AB plane, respectively. Specifically, the polar coordinates of the LUV model are known as the HCL (Hue-Chroma-Luminance) model (see Wikipedia (2024d), which points out that the LAB-based polar coordinates are also sometimes referred to as HCL). The HCL model captures the human perceptual axes very well without confounding effects as in the HSV or HLS approaches (more details follow below)."
  },
  {
    "objectID": "articles/color_spaces.html#overview",
    "href": "articles/color_spaces.html#overview",
    "title": "Color Spaces: Classes and Utilities",
    "section": "",
    "text": "At the core of the colorspace package are various utilities for computing with color spaces Wikipedia (2024c), as the name conveys. Thus, the package helps to map various three-dimensional representations of color to each other Ihaka (2003). A particularly important mapping is the one from the perceptually-based and device-independent color model HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color specifications in many systems based on the corresponding hex codes Wikipedia (2024g), e.g., in HTML but also in Python. For completeness further standard color models are included as well in the package. Their connections are illustrated in the following graph:\n\n\n\n\n\nflowchart LR\n  X[CIEXYZ]\n  PLUV((polarLUV&lt;br/&gt;HCL)) --- LUV[CIELUV] --- X\n  PLAB((polarLAB)) --- LAB[CIELAB] --- X\n  X ---|white point&lt;br&gt;= D65| RGB[RGB] ---|gamma&lt;br&gt;=2.4| sRGB[sRGB]\n  sRGB --- HSV((HSV))\n  sRGB --- hex{HEX}\n  sRGB --- HLS((HLS))\n\n\n\n\n\n\nColor models that are (or try to be) perceptually-based are displayed with circles and models that are not are displayed with rectangles. The corresponding classes in colorspace are:\n\nRGB for the classic Red-Green-Blue color model, which mixes three primary colors with different intensities to obtain a spectrum of colors. The advantage of this color model is (or was) that it corresponded to how computer and TV screens generated colors, hence it was widely adopted and still is the basis for color specifications in many systems. For example, hex color codes are employed in HTML but also in Python. However, the RGB model also has some important drawbacks: It does not take into account the output device properties, it is not perceptually uniform (a unit step within RGB does not produce a constant perceptual change in color), and it is unintuitive for humans to specify colors (say brown or pink) in this space. Wikipedia (2024c)\nsRGB addresses the issue of device dependency by adopting a so-called gamma correction. Therefore, the gamma-corrected standard RGB (sRGB), as opposed to the linearized RGB above, is a good model for specifying colors in software and for hardware. But it is still unintuitive for humans to work directly with this color space. Therefore, sRGB is a good place to end up in a color space manipulation but it is not a good place to start. Wikipedia (2024f)\nHSV is a simple transformation of the (s)RGB space that tries to capture the perceptual axes: hue (dominant wavelength, the type of color), saturation (colorfulness), and value (brightness, i.e., light vs. dark). Unfortunately, the three axes in the HSV model are confounded so that, e.g., brightness changes dramatically with hue. Wikipedia (2024g)\nHSL (Hue-Lightness-Saturation) is another transformation of (s)RGB that tries to capture the perceptual axes. It does a somewhat better job but the dimensions are still strongly confounded. Wikipedia (2024e)\nCIEXYZ was established by the CIE (Commission Internationale de l’Eclairage) based on experiments with human subjects. It provides a unique triplet of XYZ values, coding the standard observer’s perception of the color. It is device-independent but it is not perceptually uniform and the XYZ coordinates have no intuitive meaning. Wikipedia (2024a)\nCIELUV and CIELAB were therefore proposed by the CIE as perceptually uniform color spaces where the former is typically preferred for emissive technologies (such as screens and monitors) whereas the latter is usually preferred when working with dyes and pigments. The L coordinate in both spaces has the same meaning and captures luminance (light-dark contrasts). Both the U and V coordinates as well as the A and B coordinates measure positions on red/green and yellow/blue axes, respectively, albeit in somewhat different ways. While this corresponds to how human color vision likely evolved (see the next section), these two color models still not correspond to perceptual axes that humans use to describe colors. Wikipedia (2024e),Wikipedia (2024b)\npolarLUV (=HCL) and polarLAB therefore take polar coordinates in the UV plane and AB plane, respectively. Specifically, the polar coordinates of the LUV model are known as the HCL (Hue-Chroma-Luminance) model (see Wikipedia (2024d), which points out that the LAB-based polar coordinates are also sometimes referred to as HCL). The HCL model captures the human perceptual axes very well without confounding effects as in the HSV or HLS approaches (more details follow below)."
  },
  {
    "objectID": "articles/color_spaces.html#human-color-vision-and-the-hcl-color-model",
    "href": "articles/color_spaces.html#human-color-vision-and-the-hcl-color-model",
    "title": "Color Spaces: Classes and Utilities",
    "section": "Human color vision and the HCL color model",
    "text": "Human color vision and the HCL color model\nIt has been hypothesized that human color vision has evolved in three distinct stages:\n\nPerception of light/dark contrasts (monochrome only).\nYellow/blue contrasts (usually associated with our notion of warm/cold colors).\nGreen/red contrasts (helpful for assessing the ripeness of fruit).\n\nSee Kaiser and Boynton (1996), Knoblauch (2002), Ihaka (2003), Lumley (2013) and/or Zeileis, Hornik, and Murrell (2007) for more details and references. Thus, colors can be described using a 3-dimensional space:\n\n\n\nRepresentation of the three axis of human color vision.\n\n\nHowever, for describing colors in such a space, it is more natural for humans to employ polar coordinates in the color plane (yellow/blue vs. green/red, visualized by the dashed circle above) plus a third light/dark axis. Hence, color models that attempt to capture these perceptual axes are also called perceptually-based color spaces. As already argued above, the HCL model captures these dimensions very well, calling them: hue, chroma, and luminance.\nThe corresponding sRGB gamut, i.e., the HCL colors that can also be represented in sRGB, is visualized in the animation below (Horvath and Lipka 2016).\n\nLink to video (wikimedia.org)\n\nThe shape of the HCL space is a distorted double cone which is seen best by looking at vertical slices, i.e., chroma-luminance planes for given hues. For example, the left panel below depicts the chroma-luminance plane for a certain blue (hue = 255). Along with luminance the colors change from dark to light. With increasing chroma the colors become more colorful, where the highest chroma is possible for intermediate luminance.\nAs some colors are relatively dark (e.g., blue and red assume their maximum chroma for relatively low luminances) while others are relatively light (e.g., yellow and green), horizontal slices of hue-chroma planes for given hue have somewhat irregular shapes. The right panel below shows such a hue-chroma plane for moderately light colors (luminance = 70). At that luminance, green and orange can become much more colorful compared to blue or red."
  },
  {
    "objectID": "articles/color_spaces.html#illustration-of-basic-colorspace-functionality",
    "href": "articles/color_spaces.html#illustration-of-basic-colorspace-functionality",
    "title": "Color Spaces: Classes and Utilities",
    "section": "Illustration of basic colorspace functionality",
    "text": "Illustration of basic colorspace functionality\nAs an example a vector of colors x can be specified in the HCL (or polar LUV) model:\nfrom colorspace.colorlib import HCL\nx = HCL(H = [0, 120, 240], C = [50.] * 3, L = [70.] * 3)\nprint(x)\n\n\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:    0.00   50.00   70.00\n      120.00   50.00   70.00\n      240.00   50.00   70.00\n\n\n\nThe resulting three colors are pastel red (hue = 0), green (hue = 120), and blue (hue = 240) with moderate chroma and luminance. For display in other systems an sRGB representation might be needed:\nx.to(\"sRGB\")    # Convert to sRGB coordinates\nprint(x)\n\n\n\nsRGB color object (3 colors)\n           R       G       B\n  1:    0.89    0.59    0.65\n        0.53    0.72    0.46\n        0.49    0.69    0.87\n\n\n\nThe displayed coordinates can also be extracted as numeric matrices by the calling the .get() method on a colorobject. As an example we convert the three colors to the HSV color space and extract the saturation coordinate only by calling x.get(\"S\").\nx.to(\"HSV\")\nprint(x)\nprint(x.get(\"S\"))     # Saturation dimension only\n\n\n\nHSV color object (3 colors)\n           H       S       V\n  1:  348.07    0.34    0.89\n      104.61    0.36    0.72\n      208.07    0.43    0.87\n[0.34460077 0.36458245 0.4341857 ]\n\n\n\nFor display in many systems hex color codes based on the sRGB coordinates can be created:\nprint(x.colors())     # Automatically converts to hex\n\n\n\n['#E495A5', '#86B875', '#7DB0DD']"
  },
  {
    "objectID": "articles/color_spaces.html#color-library",
    "href": "articles/color_spaces.html#color-library",
    "title": "Color Spaces: Classes and Utilities",
    "section": "Color library",
    "text": "Color library\nThe workhorse of these transformations is the colorlib class which allows to transform colorobject objects into each other.\n\ncolorlib\ncolorobject\n\nThe following classes (all inheriting from colorobject) are available to create colors in different color spaces: polarLUV (HCL), CIELUV, polarLAB, CIELAB, CIEXYZ, RGB, sRGB, HSV, HLS, hexcols, colorlib.\nColors can be transformed from and to (mostly all) color spaces using the .to(&lt;name of color space&gt;) method (see e.g., hexcols.to)."
  },
  {
    "objectID": "articles/color_spaces.html#matplotlib-color-maps",
    "href": "articles/color_spaces.html#matplotlib-color-maps",
    "title": "Color Spaces: Classes and Utilities",
    "section": "Matplotlib color maps",
    "text": "Matplotlib color maps\nIn addition many objects provided by the colorspace package allow to convert a series of colors (color palette) into a matplotlib.colors.LinearSegmentedColormap ‘cmap’ used by matplotlib. As an example using the object x from above:\nfrom colorspace import palette\ncmap = palette(x, \"custom cmap palette\").cmap()\nprint(cmap.N)\ncmap\n\n\n\n3\n\n\n\n\ncustom cmap palette  underbad over \n\n\n\nPlease note that matplotlib performs linear interpolation in the sRGB color space between the colors specified. This allows us to draw more than 3 colors from the color map above. However, this may result in skewed color gradients!\nThe better way to go is to define/design your custom palette in the HCL color space using qualitative_hcl, diverging_hcl, divergingx_hcl, and sequential_hcl among others (see :ref:HCL-Based Color Palettes &lt;article-hcl_palettes&gt; for details).\nThese classes define color palettes via functions in the HCL color space and allow to draw large numbers of colors along the function space. The .cmap() will still return a matplotlib.colors.LinearSegmentedColormap but (by default) based on n = 101 distinct colors which will require less linear interpolation.\nfrom colorspace import diverging_hcl\npal  = diverging_hcl(\"Green-Orange\")\ncmap = pal.cmap()\nprint(cmap.N)\ncmap\n\n\n\n101\n\n\n\n\ncustom_hcl_cmap  underbad over \n\n\n\nA simple example using matplotlib.pyplot.contourf with a custom HCL based color palette (sequential_hcl(\"Rocket\").cmap()):\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import ma\nfrom matplotlib import ticker, cm\n\n# Custom color map\nfrom colorspace import sequential_hcl\ncmap = sequential_hcl(\"Rocket\").cmap()\n\nN = 100\nx = np.linspace(-3.0, 3.0, N)\ny = np.linspace(-2.0, 2.0, N)\nX, Y = np.meshgrid(x, y)\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale so we see both hump and spike.\n# linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\n# Put in some negative values (lower left corner) to cause trouble with logs:\nz[:5, :5] = -1\n\n# The following is not strictly essential, but it will eliminate\n# a warning.  Comment it out to see the warning.\nz = ma.masked_where(z &lt;= 0, z)\n\n# Automatic selection of levels works; setting the\n# log locator tells contourf to use a log scale:\n# Matlplotlib.contourf decides to draw 9 levels\nfig, ax = plt.subplots()\ncs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cmap)\n\nplt.show()"
  },
  {
    "objectID": "articles/classes_and_methods.html",
    "href": "articles/classes_and_methods.html",
    "title": "Main Classes and Methods",
    "section": "",
    "text": "At the core of the colorspace package are various utilities for computing with color spaces (Wikipedia 2024a), as the name conveys. Thus, the package helps to map various three-dimensional representations of color to each other (Ihaka 2003). A particularly important mapping is the one from the perceptually-based and device-independent color model HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color specifications in many systems based on the corresponding hex codes (Wikipedia 2024b), e.g., in HTML but also in R. For completeness further standard color models are included as well in the package. Their connections are illustrated in the following graph:\nTODO(Reto): Last article to be updated, describe core classes and design idea of the Python colorspace package, also used for JOSS submission.\n\nfrom colorspace import palette\npal = palette([\"#c3c3c3\", \"#DD0000\"], \"Demo\")\n\n\nhclpalettes\npalette\nqualitative_hcl\ndiverging_hcl\nsequential_hcl\nrainbow_hcl\nheat_hcl\nterrain_hcl\ndiverging_hsv\ntritan\nprotan\ndeutan\ndesaturate\nhcl_palettes\nswatchplot\nspecplot\nchoose_palette\ncvd_emulator\n\ndefaultpalette not intended to be used by the user. Reads the config files (shipped with the Python package) and returns all available default palettes. Called by hclpalettes.\nhclpalettes serves as the super class for the following color palettes.\n\nqualitative_hcl.\ndiverging_hcl.\ndivergingx_hcl.\nsequential_hcl.\nrainbow_hcl, a convenience palette for qualitative HCL rainbow.\nheat_hcl an HCL approximation of Rs old heat palette.\nterrain_hcl an HCL approxmation of Rs terrain palette.\ndiverging_hcl an HSV based diverging color palette."
  },
  {
    "objectID": "articles/classes_and_methods.html#overview",
    "href": "articles/classes_and_methods.html#overview",
    "title": "Main Classes and Methods",
    "section": "",
    "text": "At the core of the colorspace package are various utilities for computing with color spaces (Wikipedia 2024a), as the name conveys. Thus, the package helps to map various three-dimensional representations of color to each other (Ihaka 2003). A particularly important mapping is the one from the perceptually-based and device-independent color model HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color specifications in many systems based on the corresponding hex codes (Wikipedia 2024b), e.g., in HTML but also in R. For completeness further standard color models are included as well in the package. Their connections are illustrated in the following graph:\nTODO(Reto): Last article to be updated, describe core classes and design idea of the Python colorspace package, also used for JOSS submission.\n\nfrom colorspace import palette\npal = palette([\"#c3c3c3\", \"#DD0000\"], \"Demo\")\n\n\nhclpalettes\npalette\nqualitative_hcl\ndiverging_hcl\nsequential_hcl\nrainbow_hcl\nheat_hcl\nterrain_hcl\ndiverging_hsv\ntritan\nprotan\ndeutan\ndesaturate\nhcl_palettes\nswatchplot\nspecplot\nchoose_palette\ncvd_emulator\n\ndefaultpalette not intended to be used by the user. Reads the config files (shipped with the Python package) and returns all available default palettes. Called by hclpalettes.\nhclpalettes serves as the super class for the following color palettes.\n\nqualitative_hcl.\ndiverging_hcl.\ndivergingx_hcl.\nsequential_hcl.\nrainbow_hcl, a convenience palette for qualitative HCL rainbow.\nheat_hcl an HCL approximation of Rs old heat palette.\nterrain_hcl an HCL approxmation of Rs terrain palette.\ndiverging_hcl an HSV based diverging color palette."
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.get.html",
    "href": "man/colorspace.palettes.qualitative_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\nqualitative_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.get.html",
    "href": "man/colorspace.colorlib.HSV.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nHSV.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.sRGB_to_HSV.html",
    "href": "man/colorspace.colorlib.colorlib.sRGB_to_HSV.html",
    "title": "Convert RGB to HSV",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.sRGB_to_HSV(r, g, b)\n\n\nArguments\n\n\nrnumpy.ndarray\n\n\nIntensities for red ([0., 1.]).\n\n\ngnumpy.ndarray\n\n\nIntensities for green ([0., 1.]).\n\n\nbnumpy.ndarray\n\n\nIntensities for blue ([0., 1.]).\n\n\n\n\nReturn\nReturns a numpy.ndarray with the corresponding coordinates in the HSV color space ([h, s, v]). Same length as the inputs."
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.set.html",
    "href": "man/colorspace.colorlib.hexcols.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nhexcols.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.dropalpha.html",
    "href": "man/colorspace.colorlib.HSV.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nHSV.dropalpha()"
  },
  {
    "objectID": "man/colorspace.hcl_palettes.hcl_palettes.html",
    "href": "man/colorspace.hcl_palettes.hcl_palettes.html",
    "title": "Pre-Defined HCL Palettes",
    "section": "",
    "text": "Description\nFunction to retrieve and/or display pre-defined color palettes based on the HCL (Hue-Chroma-Luminance) color model, excludes ‘diverging xtra’ (see divergingx_palettes).\nThe inputs type_ and name can be used to retrieve a custom subset, custom can be used to add custom palettes if if needed.\nIf plot = True, **kwargs can be used to specify the figure size of the resulting image by specifying figsize = (height, width) where both, height and width must be int/float, specifying the height and width in inches. Note that matplotlib must be installed when plot = True.\n\n\nUsage\nhcl_palettes(n=5, type_=None, name=None, plot=False,             custom=None, ncol=4, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nThe number of colors to be plotted, defaults to 7. Only used if plot = True.\n\n\ntype_None, str, list\n\n\nGiven a str or a list of str, only a subset of all available default color maps will returned/displayed. Can be used in combination with input argument name. Uses partial matching, not case sensitive.\n\n\nnameNone, str, list\n\n\nSimilar to type_. If not specified all palettes will be returned. Can be set to a str or a list of str containing the names of the palettes which should be returned/plotted.\n\n\nplotbool\n\n\nIf False (default) an object of type hclpalettes is returned, containing the (subset) of pre-defined HCL color palettes.\n\n\ncustomdefaultpalette\n\n\nOne or multiple defaultpalettes can be provided in addition.\n\n\nncolint\n\n\nPositive int, number of columns, defaults to 4.\n\n\n**kwargs\n\n\nForwarded to the main swatchplot function if plot = True.\n\n\n\n\nReturn\nNone or hclpalettes: If plot = True a plot will be created and None is returned. If plot = False (default) an object of class hclpalettes is returned.\n\n\nExamples\n\n## Basic usage:\n\nfrom colorspace import hcl_palettes\n# Get all pre-defined HCL palettes shipped with the package\nhcl_palettes()\n\nHCL palettes\n\nType:  Basic: Sequential (single-hue)\nNames: Grays, Light Grays, Blues 2, Purples 2, Reds 2\n       Greens 2\n\nType:  Basic: Sequential (multi-hue)\nNames: Purple-Blue, Red-Purple, Red-Blue, Purple-Orange\n       Blue-Yellow, Green-Yellow, Red-Yellow, Heat, Heat 2\n       Terrain, Terrain 2, Viridis, Plasma, Dark Mint, Mint\n       Emrld, BluYl, ag_GrnYl, Peach, PinkYl\n\nType:  Basic: Qualitative\nNames: Pastel 1, Dark 2, Dark 3, Set 2, Set 3, Warm, Cold\n       Harmonic, Dynamic\n\nType:  Basic: Diverging\nNames: Blue-Red, Blue-Red 2, Blue-Yellow 2, Blue-Yellow 3\n       Green-Orange, Cyan-Magenta, Tropic\n\nType:  Advanced: Sequential (single-hue)\nNames: Blues 3, Purples 3, Reds 3, Greens 3, Oslo\n\nType:  Advanced: Sequential (multi-hue)\nNames: Purple-Yellow, Inferno, Rocket, Mako, BluGrn, Teal\n       TealGrn, Burg, BurgYl, RedOr, OrYel, Purp, PurpOr\n       Sunset, Magenta, SunsetDark, ag_Sunset, BrwnYl, YlOrRd\n       YlOrBr, OrRd, Oranges, YlGn, YlGnBu, Reds, RdPu, PuRd\n       Purples, PuBuGn, PuBu, Greens, BuGn, GnBu, BuPu, Blues\n       Lajolla, Turku, Hawaii, Batlow\n\nType:  Advanced: Diverging\nNames: Blue-Red 3, Red-Green, Purple-Green, Purple-Brown\n       Green-Brown, Blue-Yellow 2, Blue-Yellow 3, Broc, Cork\n       Vik, Berlin, Lisbon, Tofino\n\n\n\n# Get all diverging HCL palettes (basic and advanced)\nhcl_palettes(type_ = \"Diverging\")\n\nHCL palettes\n\nType:  Basic: Diverging\nNames: Blue-Red, Blue-Red 2, Blue-Yellow 2, Blue-Yellow 3\n       Green-Orange, Cyan-Magenta, Tropic\n\nType:  Advanced: Diverging\nNames: Blue-Red 3, Red-Green, Purple-Green, Purple-Brown\n       Green-Brown, Blue-Yellow 2, Blue-Yellow 3, Broc, Cork\n       Vik, Berlin, Lisbon, Tofino\n\n\n\n# Get only basic diverging HCL palettes\nhcl_palettes(type_ = \"Basic: Diverging\")\n\nHCL palettes\n\nType:  Basic: Diverging\nNames: Blue-Red, Blue-Red 2, Blue-Yellow 2, Blue-Yellow 3\n       Green-Orange, Cyan-Magenta, Tropic\n\n\n\n# Get specific HCL palettes by name\nhcl_palettes(name = [\"Oranges\", \"Tropic\"]) \n\nHCL palettes\n\nType:  Basic: Diverging\nNames: Tropic\n\nType:  Advanced: Sequential (multi-hue)\nNames: Oranges\n\n\n\n# Visualize all diverging HCL palettes\nhcl_palettes(type_ = \"Diverging\", ncol = 2,\n             plot = True, figsize = (6, 4));\n\n\n\n\n\n\n\n\n\n# Visualize specific palettes selected by name\nhcl_palettes(name = [\"Oranges\", \"Tropic\"],\n             plot = True, ncol = 1, figsize = (6, 2));\n\n\n\n\n\n\n\n\n\n# Specify number of colors shown\nhcl_palettes(n = 5,  type_ = \"Basic: Diverging\",\n             plot = True, ncol = 1, figsize = (6, 3));\n\n\n\n\n\n\n\n\n\nhcl_palettes(n = 51, type_ = \"Advanced: Diverging\",\n             plot = True, ncol = 1, figsize = (6, 8));\n\n\n\n\n\n\n\n\n\n# Extract specific palettes after loading\npalettes = hcl_palettes()\nc1 = palettes.get_palette(\"Oranges\")\nc1\n\nPalette Name: Oranges\n        Type: Advanced: Sequential (multi-hue)\n        Inspired by: ...\n         c1            70\n         c2            10\n         cmax         150\n         fixup       True\n         gui            0\n         h1            20\n         h2            55\n         l1            30\n         l2            97\n         p1           1.2\n         p2           1.3\n\n\n\nc2 = palettes.get_palette(\"Greens\")\nc2\n\nPalette Name: Greens\n        Type: Advanced: Sequential (multi-hue)\n        Inspired by: ...\n         c1            35\n         c2             5\n         cmax          70\n         fixup       True\n         gui            1\n         h1           135\n         h2           115\n         l1            25\n         l2            98\n         p1           1.0\n         p2           1.5\n\n\n\n# Modify palettes by overwriting palette settings\nc1.set(h1 = 99, l2 = 30, l1 = 30)\nc1.rename(\"Custom Palette #1\")\nc2.set(h1 = -30, l1 = 40, l2 = 30, c1 = 30, c2 = 40)\nc2.rename(\"Custom Palette #2\")\n\n# Visualize customized palettes\nhcl_palettes(type_ = \"Custom\", custom = [c1, c2],\n             plot = True, ncol = 1, figsize = (6, 1));\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If n/ncol not of type int.\n\nTypeError: If type_ is not None or str.\n\nTypeError: If not is bool plot.\n\nTypeError: In case custom is an invalid input.\n\nValueError: If n or ncol are not positive.\n\nException: If no palettes can be found matching the type_ argument.",
    "crumbs": [
      "Home",
      "Function references",
      "hcl_palettes"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.cmap.html",
    "href": "man/colorspace.palettes.diverging_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\ndiverging_hcl.cmap(n=101,                   name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.specplot.html",
    "href": "man/colorspace.palettes.rainbow_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nrainbow_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.get.html",
    "href": "man/colorspace.palettes.rainbow.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\nrainbow.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.get_whitepoint.html",
    "href": "man/colorspace.colorlib.CIEXYZ.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nCIEXYZ.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.colors.html",
    "href": "man/colorspace.colorlib.polarLUV.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\npolarLUV.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.divergingx_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\ndivergingx_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.LUV_to_XYZ.html",
    "href": "man/colorspace.colorlib.colorlib.LUV_to_XYZ.html",
    "title": "Convert CIELUV to CIELAB.",
    "section": "",
    "text": "Description\nL, U, and V specify the values in the three coordinates of the CIELAB color space, XN, YN, and ZN allow to specify additional CIE chromaticities to specify a specific white point.\n\n\nUsage\ncolorlib.LUV_to_XYZ(L, U, V, XN=None, YN=None,                    ZN=None)\n\n\nArguments\n\n\nLnumpy.ndarray\n\n\nValues for the L dimension.\n\n\nUnumpy.ndarray\n\n\nValues for the U dimension.\n\n\nVnumpy.ndarray\n\n\nValues for the V dimension.\n\n\nXNNone, numpy.ndarray\n\n\nChromaticity of the white point. If of length 1, the white point specification will be recycled if needed. When not specified (all None) a default white point is used.\n\n\nYN\n\n\nSee XN.\n\n\nZN\n\n\nSee XN.\n\n\n\n\nReturn\nReturns corresponding coordinates of CIE chromaticities as a list of numpy.ndarrays of the same length as the inputs ([L, A, B])."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.html",
    "href": "man/colorspace.colorlib.polarLUV.html",
    "title": "Create polarLUV (HCL) Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the polar representation of the CIELUV color space, also known as the Hue-Chroma-Luminance (HCL) color space. Can be converted to: CIEXYZ, CIELUV, CIELAB, RGB, sRGB, polarLAB, and hexcols. Not allowed (ambiguous) are transformations to HSV and HLS.\n\n\nUsage\npolarLUV(H, C, L, alpha=None)\n\n\nArguments\n\n\nHint, float, list, numpy.array\n\n\nNumeric value(s) for hue dimension ([-360., 360.]).\n\n\nCint, float, list, numpy.array\n\n\nNumeric value(s) for chroma dimension ([0., 100.+]).\n\n\nLint, float, list, numpy.array\n\n\nNumeric value(s) for luminance dimension ([0., 100.]).\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\npolarLUV.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\npolarLUV.dropalpha()\n\n\nRemove Alpha Channel\n\n\npolarLUV.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\npolarLUV.get_whitepoint()\n\n\nGet White Point\n\n\npolarLUV.hasalpha()\n\n\nCheck for Alpha Channel\n\n\npolarLUV.length()\n\n\nGet Number of Colors\n\n\npolarLUV.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\npolarLUV.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\npolarLUV.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\npolarLUV.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\npolarLUV.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import polarLUV, HCL\n# Constructing color object with one single color via float\npolarLUV(100., 30, 50.)\n\npolarLUV color object (1 colors)\n           H       C       L\n  1:  100.00   30.00   50.00\n\n\n\n# polarLUV is the HCL color space, this\n#  is equivalent to the command above.\nHCL(100., 30, 50.)\n\npolarLUV color object (1 colors)\n           H       C       L\n  1:  100.00   30.00   50.00\n\n\n\n# Constructing object via lists\nHCL([100, 80], [30, 50], [30, 80])\n\npolarLUV color object (2 colors)\n           H       C       L\n  1:  100.00   30.00   30.00\n       80.00   50.00   80.00\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\nHCL(asarray([100, 80]), asarray([30, 50]), asarray([30, 80]))\n\npolarLUV color object (2 colors)\n           H       C       L\n  1:  100.00   30.00   30.00\n       80.00   50.00   80.00",
    "crumbs": [
      "Home",
      "Class references",
      "polarLUV"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.html",
    "href": "man/colorspace.colorlib.sRGB.html",
    "title": "Create Standard RGB (sRGB) Color Object",
    "section": "",
    "text": "Description\nAllows conversions to: CIELAB, CIELUV, CIEXYZ, HLS, HSV, RGB, hexcols. polarLAB and polarLUV.\n\n\nUsage\nsRGB(R, G, B, alpha=None, gamma=None)\n\n\nArguments\n\n\nRint, float, list, numpy.array\n\n\nNumeric value(s) for red intensity ([0., 1.]).\n\n\nGint, float, list, numpy.array\n\n\nNumeric value(s) for green intensity ([0., 1.]).\n\n\nBint, float, list, numpy.array\n\n\nNumeric value(s) for blue intensity ([0., 1.]).\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\ngammaNone, float\n\n\nIf None (default) the default gamma value is used. Can be specified to overwrite the default.\n\n\n\n\nMethods\n\n\nsRGB.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nsRGB.dropalpha()\n\n\nRemove Alpha Channel\n\n\nsRGB.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nsRGB.get_whitepoint()\n\n\nGet White Point\n\n\nsRGB.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nsRGB.length()\n\n\nGet Number of Colors\n\n\nsRGB.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nsRGB.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nsRGB.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nsRGB.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nsRGB.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import sRGB\n# Constructing color object with one single color via float\nsRGB(1., 0.3, 0.5)\n\nsRGB color object (1 colors)\n           R       G       B\n  1:    1.00    0.30    0.50\n\n\n\n# Constructing object via lists\nsRGB([1., 0.8], [0.5, 0.5], [0.0, 0.2])\n\nsRGB color object (2 colors)\n           R       G       B\n  1:    1.00    0.50    0.00\n        0.80    0.50    0.20\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\nsRGB(asarray([1., 0.8]), asarray([0.5, 0.5]), asarray([0.0, 0.2]))\n\nsRGB color object (2 colors)\n           R       G       B\n  1:    1.00    0.50    0.00\n        0.80    0.50    0.20",
    "crumbs": [
      "Home",
      "Class references",
      "sRGB"
    ]
  },
  {
    "objectID": "man/colorspace.specplot.specplot.html",
    "href": "man/colorspace.specplot.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of color palettes (given as hex codes) in HCL and/or RGB coordinates.\nAs the hues for low-chroma colors are not (or poorly) identified, by default a smoothing is applied to the hues (fix = TRUE). Also, to avoid jumps from 0 to 360 or vice versa, the hue coordinates are shifted suitably.\n\n\nUsage\nspecplot(x, y=None, hcl=True, palette=True,         fix=True, rgb=False, title=None, fig=None,         **figargs)\n\n\nArguments\n\n\nxlist\n\n\nlist of str (hex colors or standard-names of colors).\n\n\nyNone or list\n\n\nif set it must be a list of str (see x) with the very same length as the object provided on argument x. Allows to draw two sets of colors for comparison, defaults to None.\n\n\nhclbool\n\n\nWhether or not to plot the HCL color spectrum.\n\n\npalettebool\n\n\nWhether or not to plot the colors as a color map.\n\n\nfixbool\n\n\nShould the hues be fixed to be on a smooth(er) curve? Details in the functions description.\n\n\nrgbbool\n\n\nWhether or not to plot the RGB color spectrum, defaults to False.\n\n\ntitleNone or str\n\n\ntitle of the figure. Defaults to None (no title).\n\n\nfigNone, matplotlib.figure.Figure\n\n\nIf None, a new matplotlib.figure.Figure is created.\n\n\n**figargs\n\n\nforwarded to matplotlib.pyplot.subplot. Only has an effect if fig = None.\n\n\n\n\nExamples\n\nfrom colorspace import rainbow_hcl\nfrom colorspace import specplot\npal = rainbow_hcl(100)\nspecplot(pal.colors());\n\n\n\n\n\n\n\n\n\nspecplot(pal.colors(), rgb = False, hcl = True, palette = False);\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If x is not a list.\n\nTypeError: If y is neither a list nor None.\n\nValueError: If x contains str which can not be converted to hex colors.\n\nValueError: If y contains str which can not be converted to hex colors.\n\nValueError: If y is not the same length as y. Only checked if y is not None.\n\nTypeError: If either rgb, hcl, or palette is not bool.\n\nValueError: If all, rgb, hcl and palette are set to False as this would result in an empty plot.\n\nTypeError: If 'title' is neither None nor str.",
    "crumbs": [
      "Home",
      "Function references",
      "specplot"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.get.html",
    "href": "man/colorspace.palettes.rainbow_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\nrainbow_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.colors.html",
    "href": "man/colorspace.palettes.terrain_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\nterrain_hcl.colors(n=11, fixup=True, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned.\n\n\nfixupNone, bool\n\n\nShould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return."
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.get.html",
    "href": "man/colorspace.palettes.sequential_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\nsequential_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.colorlib.compare_colors.html",
    "href": "man/colorspace.colorlib.compare_colors.html",
    "title": "Compare Sets of Colors",
    "section": "",
    "text": "Description\nCompares two sets of colors based on two color objects. The objects provided on argument a and b must inherit from colorobject. This can be any of the following classes: CIELAB, CIELUV, CIEXYZ, HLS, HSV, RGB, hexcols, polarLAB, polarLUV, or sRGB.\n\n\nUsage\ncompare_colors(a, b, exact=False, _all=True,               atol=None)\n\n\nArguments\n\n\nacolorobject\n\n\nObject which inherits from colorobject.\n\n\nbcolorobject\n\n\nObject which inherits from colorobject.\n\n\nexactbool\n\n\nDefault False, check for colors being nearly equal (see atol). If set to True the coordinates must be identical. Note: in case a and b are hex colors (colorspace.colorlib.hexcols) strings will always be matched exactly.\n\n\n_allbool\n\n\nDefault True; the function will return True if all colors are identical/nearly equal. If set to False the return will be a list of bool containing True and False for each pair of colors.\n\n\natolNone or float\n\n\nAbsolute tolerance for the distance measure between two colors to be considered as nearly equal. Only used if exact = False, else atol = 1e-6 is used. If set to None the tolerance will automatically be set depending on the type of the objects. Defaults to None.\n\n\n\n\nReturn\nbool, list: Returns True if all colors of a are exactly equal or nearly equal (see arguments) to the colors in object b. If _all = False, a list of bool is returned indicating pair-wise comparison of all colors in a and b.\n\n\nExamples\n\nfrom colorspace.colorlib import *\n# Three RGB colors\na = RGB([0.5, 0.5], [0.1, 0.1], [0.9, 0.9])\nb = RGB([0.5, 0.5], [0.1, 0.1], [0.9, 0.91])\n\ncompare_colors(a, b)\n\nFalse\n\n\n\ncompare_colors(a, b, atol = 0.1)\n\nTrue\n\n\n\ncompare_colors(a, b, exact = True)\n\nFalse\n\n\n\ncompare_colors(a, b, exact = True, _all = False)\n\narray([ True, False])\n\n\n\n# Same example using two sets of hexcolor objects\nx = hexcols([\"#ff00ff\", \"#003300\"])\ny = hexcols([\"#ff00ff\", \"#003301\"])\ncompare_colors(x, y)\n\nFalse\n\n\n\ncompare_colors(x, y, _all = False)\n\n[True, False]\n\n\n\n# Convert HEX to HCL (polarLUV) and back, compare the\n# resulting colors to the original ones; should be identical\nfrom copy import deepcopy\nz  = hexcols([\"#ff00ff\", \"#003301\"])\nzz = deepcopy(z)\nzz.to(\"HCL\")\nprint(zz)\n\npolarLUV color object (2 colors)\n           H       C       L\n  1:  307.73  137.40   60.32\n      128.06   26.54   17.32\n\n\n\nzz.to(\"hex\")\nprint(zz)\n\nhexcols color object (2 colors)\n        hex_\n  1:b'#FF00FF'\n    b'#003301'\n\n\n\ncompare_colors(z, zz)\n\nTrue\n\n\n\n\nRaises\n\n\nTypeError: If a or b are not objects of a class which inherits from colorobject.\n\nTypeError: If a and b are not of the same class.\n\nValueError: If a and b are not of the same length, i.e., do not contain the same number of colors.\n\nValueError: If exact or _all are not bool.\n\nValueError: If atol is neither None nor float.",
    "crumbs": [
      "Home",
      "Function references",
      "compare_colors"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.dropalpha.html",
    "href": "man/colorspace.colorlib.RGB.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nRGB.dropalpha()"
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.get_whitepoint.html",
    "href": "man/colorspace.colorlib.HLS.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nHLS.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.palettes.hclpalettes.get_palette.html",
    "href": "man/colorspace.palettes.hclpalettes.get_palette.html",
    "title": "Get Palette by Name",
    "section": "",
    "text": "Description\nGet a palette with a specific name.\n\n\nUsage\nhclpalettes.get_palette(name)\n\n\nArguments\n\n\nnamestr\n\n\nName of the color palette which should be returned. Not case sensitive; blanks are ignored (removed).\n\n\n\n\nReturn\nReturns an object of class defaultpalette if a palette with the name as specified can be found. Else an error will be dropped."
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.specplot.html",
    "href": "man/colorspace.palettes.heat_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nheat_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.swatchplot.html",
    "href": "man/colorspace.colorlib.HSV.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nHSV.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.specplot.html",
    "href": "man/colorspace.colorlib.CIEXYZ.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nCIEXYZ.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.palette.colors.html",
    "href": "man/colorspace.palettes.palette.colors.html",
    "title": "Get Palette Colors",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\npalette.colors(*args, **kwargs)\n\n\nArguments\n\n\n*args\n\n\nIgnored.\n\n\n**kwargs\n\n\nIgnored.\n\n\n\n\nReturn\nList of all colors of the palette."
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.name.html",
    "href": "man/colorspace.palettes.divergingx_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\ndivergingx_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.length.html",
    "href": "man/colorspace.colorlib.sRGB.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nsRGB.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.sRGB_to_hex.html",
    "href": "man/colorspace.colorlib.colorlib.sRGB_to_hex.html",
    "title": "Convert Standard RGB (sRGB) to Hex Colors",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.sRGB_to_hex(r, g, b, fixup=True)\n\n\nArguments\n\n\nrnumpy.ndarray\n\n\nIntensities for red ([0., 1.,]).\n\n\ngnumpy.ndarray\n\n\nIntensities for green ([0., 1.,]).\n\n\nbnumpy.ndarray\n\n\nIntensities for blue ([0., 1.,]).\n\n\nfixupbool\n\n\nWhether or not the rgb values should be corrected if they lie outside the defined RGB space (outside [0., 1.,]), defaults to True.\n\n\n\n\nReturn\nA list with hex color str."
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.html",
    "href": "man/colorspace.colorlib.CIEXYZ.html",
    "title": "Create CIEXYZ Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the CIEXYZ color space. Can be converted to: CIEXYZ, CIELUV, CIELAB, RGB, sRGB, polarLAB, and hexcols. Not allowed (ambiguous) are transformations to HSV and HLS.\n\n\nUsage\nCIEXYZ(X, Y, Z, alpha=None)\n\n\nArguments\n\n\nXint, float, list, numpy.array\n\n\nNumeric value(s) for X dimension.\n\n\nYint, float, list, numpy.array\n\n\nNumeric value(s) for Y dimension.\n\n\nZint, float, list, numpy.array\n\n\nNumeric value(s) for Z dimension.\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\nCIEXYZ.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nCIEXYZ.dropalpha()\n\n\nRemove Alpha Channel\n\n\nCIEXYZ.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nCIEXYZ.get_whitepoint()\n\n\nGet White Point\n\n\nCIEXYZ.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nCIEXYZ.length()\n\n\nGet Number of Colors\n\n\nCIEXYZ.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nCIEXYZ.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nCIEXYZ.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nCIEXYZ.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nCIEXYZ.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import CIEXYZ\n# Constructing color object with one single color via float\nCIEXYZ(80, 30, 10)\n\nCIEXYZ color object (1 colors)\n           X       Y       Z\n  1:   80.00   30.00   10.00\n\n\n\n# Constructing object via lists\nCIEXYZ([10, 0], [20, 80], [40, 40])\n\nCIEXYZ color object (2 colors)\n           X       Y       Z\n  1:   10.00   20.00   40.00\n        0.00   80.00   40.00\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\nCIEXYZ(asarray([10, 0]), asarray([20, 80]), asarray([40, 40]))\n\nCIEXYZ color object (2 colors)\n           X       Y       Z\n  1:   10.00   20.00   40.00\n        0.00   80.00   40.00",
    "crumbs": [
      "Home",
      "Class references",
      "CIEXYZ"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.swatchplot.html",
    "href": "man/colorspace.palettes.rainbow.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nrainbow.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.set.html",
    "href": "man/colorspace.colorlib.polarLAB.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\npolarLAB.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.hasalpha.html",
    "href": "man/colorspace.colorlib.CIELUV.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nCIELUV.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.html",
    "href": "man/colorspace.palettes.sequential_hcl.html",
    "title": "Sequential HCL Color Palettes",
    "section": "",
    "text": "Description\nSee also: qualitative_hcl, diverging_hcl, divergingx_hcl, rainbow_hcl, heat_hcl, terrain_hcl, diverging_hsv, and rainbow.\n\n\nUsage\nsequential_hcl(h=260, c=[80, 0], l=[30, 90],               power=1.5, fixup=True, palette=None,               rev=False, *args, **kwargs)\n\n\nArguments\n\n\nhnumeric\n\n\nHue values (color). If only one value is given the value is recycled which yields a single-hue sequential color palette. If input h is a str this argument acts like the palette argument (see palette input parameter).\n\n\ncnumeric list\n\n\nChroma values (colorfullness), numeric of length one (constant chroma), two (linear), or three (advanced; [c1, c2, cmax]).\n\n\nlnumeric list\n\n\nLuminance values (luminance), numeric of length two. If multiple values are provided only the first one will be used.\n\n\npowernumeric, numeric list\n\n\nPower parameter for non-linear behaviour of the color palette. One or two values can be provided.\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\npalettestr\n\n\nCan be used to load a default diverging color palette specification. If the palette does not exist an exception will be raised. Else the settings of the palette as defined will be used to create the color palette.\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nCurrently unused.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\nsequential_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\nsequential_hcl.colors(n=11, fixup=True, **kwargs)\n\n\nGet Colors\n\n\nsequential_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\nsequential_hcl.name()\n\n\nGet Palette Name\n\n\nsequential_hcl.show_settings()\n\n\nShow Palette Settings\n\n\nsequential_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\nsequential_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import sequential_hcl\na = sequential_hcl()\na.colors(10)\n\n['#023FA5',\n '#4359A7',\n '#6371AF',\n '#7D87B9',\n '#959CC3',\n '#ABB0CC',\n '#BEC1D4',\n '#CFD0DA',\n '#DBDCE0',\n '#E2E2E2']\n\n\n\n# Different color palette by name\nb = sequential_hcl(\"Peach\")\nb.colors(10)\n\n['#EA4C3B',\n '#ED6343',\n '#F0764E',\n '#F3885B',\n '#F5996B',\n '#F7A87C',\n '#F8B78E',\n '#F9C5A0',\n '#FAD2B3',\n '#FADDC3']\n\n\n\nb.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\nsequential_hcl(\"Peach\")(10)\n\n['#EA4C3B',\n '#ED6343',\n '#F0764E',\n '#F3885B',\n '#F5996B',\n '#F7A87C',\n '#F8B78E',\n '#F9C5A0',\n '#FAD2B3',\n '#FADDC3']",
    "crumbs": [
      "Home",
      "Class references",
      "sequential_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.dropalpha.html",
    "href": "man/colorspace.colorlib.CIELUV.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nCIELUV.dropalpha()"
  },
  {
    "objectID": "man/colorspace.CVD.desaturate.html",
    "href": "man/colorspace.CVD.desaturate.html",
    "title": "Desaturate Colors by Chroma Removal in HCL Space",
    "section": "",
    "text": "Description\nTransform a vector of given colors to the corresponding colors with chroma reduced (by a tunable amount) in HCL space.\nThe color object (col) is transformed to the HCL color space where the chroma is reduced, before converted back to the original color space.\nSee also: deutan, protan, tritan, desaturate, and cvd_emulator.\n\n\nUsage\ndesaturate(cols, amount=1.0)\n\n\nArguments\n\n\ncolsstr, list, matplotlib.colors.LinearSegmentedColormap, colorobject\n\n\nSingle hex color, list of hex colors (str), a matoplotlib cmap, or a color color object (such as RGB, hexcols, CIELUV).\n\n\namountfloat\n\n\nA value in [0.,1.] defining the degree of desaturation. amount = 1. removes all color, amount = 0. none, defaults to 1..\n\n\n\n\nReturn\nReturns a list of modified hex colors.\n\n\nExamples\n\nfrom colorspace import palette, diverging_hcl, desaturate\nfrom colorspace import specplot, swatchplot\nfrom colorspace.colorlib import hexcols\ncols = hexcols(diverging_hcl()(10))\nspecplot(desaturate(cols));\n\n\n\n\n\n\n\n\n\nspecplot(desaturate(cols, 0.5));\n\n\n\n\n\n\n\n\n\n# Take a list of colors which can be interpreted/translated to hex\n# colors and desaturate them via the HCL color space\ncols = [\"magenta\", \"red\", \"orange\", \"#F2F204\", \"#6BF204\", \"#4DA00D\"]\ndesaturate(cols)\n\n['#919191', '#7F7F7F', '#B8B8B8', '#EAEAEA', '#D5D5D5', '#8D8D8D']\n\n\n\nswatchplot([cols, desaturate(cols)],\n           show_names = False, figsize = (5, 1.5));\n\n\n\n\n\n\n\n\n\n# Desaturate palette object (same colors as above)\npal = palette(cols, name = \"custom palette\")\ndesaturate(pal)\n\n['#919191', '#7F7F7F', '#B8B8B8', '#EAEAEA', '#D5D5D5', '#8D8D8D']\n\n\n\n# Desaturate a matplotlib cmap object\ndesaturate(pal.cmap())\n\ncustom palette  underbad over",
    "crumbs": [
      "Home",
      "Function references",
      "desaturate"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.cmap.html",
    "href": "man/colorspace.palettes.diverging_hsv.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\ndiverging_hsv.cmap(n=101,                   name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.colors.html",
    "href": "man/colorspace.palettes.divergingx_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\ndivergingx_hcl.colors(n=11, fixup=True, alpha=None,                      **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned.\n\n\nfixupNone, bool\n\n\nShould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\nalphaNone, float\n\n\nFloat (single value) or vector of floats in the range of [0.,1.] for alpha transparency channel (0. means full transparency, 1. opaque). If a single value is provided it will be applied to all colors, if a vector is given the length has to be n.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return."
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.cmap.html",
    "href": "man/colorspace.palettes.rainbow.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\nrainbow.cmap(n=101,             name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.specplot.html",
    "href": "man/colorspace.colorlib.polarLAB.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\npolarLAB.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.length.html",
    "href": "man/colorspace.colorlib.polarLAB.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\npolarLAB.length()"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.colors.html",
    "href": "man/colorspace.palettes.diverging_hsv.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\ndiverging_hsv.colors(n=11, fixup=True, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned.\n\n\nfixupNone, bool\n\n\nShould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.get.html",
    "href": "man/colorspace.colorlib.polarLAB.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\npolarLAB.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.get_whitepoint.html",
    "href": "man/colorspace.colorlib.hexcols.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nhexcols.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.hex_to_sRGB.html",
    "href": "man/colorspace.colorlib.colorlib.hex_to_sRGB.html",
    "title": "Convert Hex Colors to Standard RGB (sRGB)",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.hex_to_sRGB(hex_, gamma=2.4)\n\n\nArguments\n\n\nhex_str, list of str\n\n\nhex color str or list of str.\n\n\ngammafloat\n\n\nGamma correction factor, defaults to 2.4.\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays with the corresponding red, green, and blue intensities ([r, g, b]), all in [0., 1.]."
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.set_whitepoint.html",
    "href": "man/colorspace.colorlib.HSV.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nHSV.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.specplot.html",
    "href": "man/colorspace.colorlib.HSV.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nHSV.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.name.html",
    "href": "man/colorspace.palettes.qualitative_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\nqualitative_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.html",
    "href": "man/colorspace.palettes.rainbow.html",
    "title": "Infamous sRGB Rainbow Color Palette",
    "section": "",
    "text": "Description\nSee also: qualitative_hcl, sequential_hcl, diverging_hcl, divergingx_hcl, rainbow_hcl, heat_hcl, terrain_hcl, and diverging_hsv.\n\n\nUsage\nrainbow(s=1, v=1, start=0,        end=&lt;function rainbow.&lt;lambda&gt; at 0x7b1b25c98720&gt;,        rev=False, *args, **kwargs)\n\n\nArguments\n\n\nsfloat, int\n\n\nsaturation value, a value in [0., 1.]. Defaults to 1.0.\n\n\nvfloat, int\n\n\nvalue, a value in [0., 1.]. Defaults to 1.0.\n\n\nstartfloat, int, function\n\n\nthe (corrected) hue in [0., 1.] at which the rainbow begins. Defaults to 0.. Can be a function with one input n (number of colors). If outside [0., 1.] it will be wrapped.\n\n\nendfloat, int, function\n\n\nthe (corrected) hue in [0., 1.] at which the rainbow ends. Defaults to 0.. Can be a function with one input n (number of colors). If outside [0., 1.] it will be wrapped.\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nUnused.\n\n\n**kwargs\n\n\nUnused.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\nrainbow.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\nrainbow.colors(n=11, alpha=None, **kwargs)\n\n\nGet Colors\n\n\nrainbow.get(key)\n\n\nGet Specific Palette Setting\n\n\nrainbow.name()\n\n\nGet Palette Name\n\n\nrainbow.show_settings()\n\n\nShow Palette Settings\n\n\nrainbow.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\nrainbow.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import rainbow\npal = rainbow()\npal.colors(10)\n\n['#FF0000',\n '#FF9900',\n '#CCFF00',\n '#33FF00',\n '#00FF66',\n '#00FFFF',\n '#0066FF',\n '#3300FF',\n '#CC00FF',\n '#FF0099']\n\n\n\npal.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\nrainbow()(10)\n\n['#FF0000',\n '#FF9900',\n '#CCFF00',\n '#33FF00',\n '#00FF66',\n '#00FFFF',\n '#0066FF',\n '#3300FF',\n '#CC00FF',\n '#FF0099']\n\n\n\n\nRaises\n\n\nValueError: If s or v are not single floating point values (or int) in the range of [0., 1.].\n\nValueError: If start and end are not float/int in [0., 1.] or functions.\n\nValueError: If rev is not bool.",
    "crumbs": [
      "Home",
      "Class references",
      "rainbow"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.length.html",
    "href": "man/colorspace.colorlib.CIELAB.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nCIELAB.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.swatchplot.html",
    "href": "man/colorspace.colorlib.CIEXYZ.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nCIEXYZ.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.set.html",
    "href": "man/colorspace.colorlib.CIELUV.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nCIELUV.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.utils.lighten.html",
    "href": "man/colorspace.utils.lighten.html",
    "title": "Algorithmically Lighten Colors",
    "section": "",
    "text": "Description\nTakes one or multiple colors and adjust them sucht hat they apper lightened. See also: darken.\n\n\nUsage\nlighten(col, amount=0.1,        method='relative',        space='HCL', fixup=True)\n\n\nArguments\n\n\ncol\n\n\ncolor (or colors) to be manipulated. Can be a color object a palette object, or a str/list of str with valid hex colors.\n\n\namountfloat\n\n\nvalue between [0., 1.] with the amount the colors should be lightened. Defaults to 0.1.\n\n\nmethodstr\n\n\neither \"relative\" (default) or \"absolute\".\n\n\nspacestr\n\n\none of \"HCL\" or \"HLS\". Defaults to \"HCL\".\n\n\nfixupbool\n\n\nshould colors which fall outside the defined RGB space be fixed (corrected)? Defaults to True.\n\n\n\n\nExamples\n\nfrom colorspace import darken, lighten, swatchplot\noriginal = \"#ff3322\"\nlighter  = lighten(original, amount = 0.3, method = \"relative\", space = \"HCL\")\ndarker   = darken(original,  amount = 0.3, method = \"relative\", space = \"HCL\")\nswatchplot([lighter, original, darker],\n           show_names = False, figsize = (6, 1));\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If method is not str.\n\nValueError: If method is not one of &quot;absolute&quot; or &quot;relative&quot;.\n\nTypeError: If space is not str.\n\nValueError: If space is not one of &quot;HCL&quot;, &quot;HLS&quot;, or &quot;combined&quot;.\n\nTypeError: If input 'col' is not among the one of the recognized objects.\n\nTypeError: If fixup is not bool.",
    "crumbs": [
      "Home",
      "Function references",
      "lighten"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.show_settings.html",
    "href": "man/colorspace.palettes.divergingx_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\ndivergingx_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.show_settings.html",
    "href": "man/colorspace.palettes.rainbow_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\nrainbow_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.length.html",
    "href": "man/colorspace.colorlib.polarLUV.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\npolarLUV.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.to.html",
    "href": "man/colorspace.colorlib.RGB.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nRGB.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.get.html",
    "href": "man/colorspace.colorlib.sRGB.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nsRGB.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.DEG2RAD.html",
    "href": "man/colorspace.colorlib.colorlib.DEG2RAD.html",
    "title": "Convert degrees into radiant",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.DEG2RAD(x)\n\n\nArguments\n\n\nxfloat, array of floats\n\n\nValue(s) in degrees.\n\n\n\n\nReturn\nfloat, float array: Returns input x in radiant."
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.dropalpha.html",
    "href": "man/colorspace.colorlib.sRGB.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nsRGB.dropalpha()"
  },
  {
    "objectID": "man/colorspace.palettes.hclpalettes.html",
    "href": "man/colorspace.palettes.hclpalettes.html",
    "title": "Prepare Predefined HCL Palettes",
    "section": "",
    "text": "Description\nPrepares the pre-specified hclpalettes. Reads the config files and creates a set of defaultpalette objects.\nSee also: divergingx_palettes.\n\n\nUsage\nhclpalettes(files=None, files_regex=None)\n\n\nArguments\n\n\nfilesNone, str list\n\n\nIf None (default) the default color palette configuration from within the package will be loaded. A path to a custom config file (str) or a list of paths can be provided to read custom palettes.\n\n\nfiles_regexNone, str\n\n\nAdditional regular expression to filter files. Only used if files = None.\n\n\n\n\nMethods\n\n\nhclpalettes.get_palette(name)\n\n\nGet Palette by Name\n\n\nhclpalettes.get_palette_types()\n\n\nGet Palette Types\n\n\nhclpalettes.get_palettes(type_=None)\n\n\nGet Type-Specific Palettes\n\n\nhclpalettes.length()\n\n\nGet Number of Palettes\n\n\nhclpalettes.plot(n=5)\n\n\nCreate swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import hclpalettes\nhclpals = hclpalettes()\nhclpals\n\nHCL palettes\n\nType:  Basic: Sequential (single-hue)\nNames: Grays, Light Grays, Blues 2, Purples 2, Reds 2\n       Greens 2\n\nType:  Basic: Sequential (multi-hue)\nNames: Purple-Blue, Red-Purple, Red-Blue, Purple-Orange\n       Blue-Yellow, Green-Yellow, Red-Yellow, Heat, Heat 2\n       Terrain, Terrain 2, Viridis, Plasma, Dark Mint, Mint\n       Emrld, BluYl, ag_GrnYl, Peach, PinkYl\n\nType:  Basic: Qualitative\nNames: Pastel 1, Dark 2, Dark 3, Set 2, Set 3, Warm, Cold\n       Harmonic, Dynamic\n\nType:  Basic: Diverging\nNames: Blue-Red, Blue-Red 2, Blue-Yellow 2, Blue-Yellow 3\n       Green-Orange, Cyan-Magenta, Tropic\n\nType:  Advanced: Sequential (single-hue)\nNames: Blues 3, Purples 3, Reds 3, Greens 3, Oslo\n\nType:  Advanced: Sequential (multi-hue)\nNames: Purple-Yellow, Inferno, Rocket, Mako, BluGrn, Teal\n       TealGrn, Burg, BurgYl, RedOr, OrYel, Purp, PurpOr\n       Sunset, Magenta, SunsetDark, ag_Sunset, BrwnYl, YlOrRd\n       YlOrBr, OrRd, Oranges, YlGn, YlGnBu, Reds, RdPu, PuRd\n       Purples, PuBuGn, PuBu, Greens, BuGn, GnBu, BuPu, Blues\n       Lajolla, Turku, Hawaii, Batlow\n\nType:  Advanced: DivergingX\nNames: ArmyRose, Earth, Fall, Geyser, TealRose, Temps, PuOr\n       RdBu, RdGy, PiYG, PRGn, BrBG, RdYlBu, RdYlGn, Spectral\n       Zissou 1, Cividis, Roma\n\nType:  Advanced: Diverging\nNames: ArmyRose, Earth, Fall, Geyser, TealRose, Temps, PuOr\n       RdBu, RdGy, PiYG, PRGn, BrBG, RdYlBu, RdYlGn, Spectral\n       Zissou 1, Cividis, Roma, Blue-Red 3, Red-Green\n       Purple-Green, Purple-Brown, Green-Brown, Blue-Yellow 2\n       Blue-Yellow 3, Broc, Cork, Vik, Berlin, Lisbon, Tofino\n\n\n\n# Palette swatch plots with 5 colors each\nhclpals.plot(n = 5);\n\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: divide by zero encountered in divide\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: invalid value encountered in divide\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: invalid value encountered in multiply\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n\n\n\n\n\n\n\n\n\n\n# Palette swatch plots with 11 colors each\nhclpals.plot(n = 11);",
    "crumbs": [
      "Home",
      "Class references",
      "hclpalettes"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.name.html",
    "href": "man/colorspace.palettes.rainbow_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\nrainbow_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.colors.html",
    "href": "man/colorspace.colorlib.polarLAB.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\npolarLAB.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.cmap.html",
    "href": "man/colorspace.palettes.heat_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\nheat_hcl.cmap(n=101,              name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.demos.demoplot.html",
    "href": "man/colorspace.demos.demoplot.html",
    "title": "Create Demo Plots",
    "section": "",
    "text": "Description\nThis function is intended to be used by the GUI (choose_palette) to visualize the color palette selected for a series of different types of plots. It can, however, also be used directly if needed.\n\n\nUsage\ndemoplot(colors, type_, n=7, ax=None, **kwargs)\n\n\nArguments\n\n\ncolors\n\n\nThe colors, any type which can be handled by palette.\n\n\ntype_str\n\n\nName of the demo function to be called. Not case sensitive.\n\n\nnint\n\n\nNumber of colors for the plot. Only used if argument colors is a palette where a dedicated number of colors must be drawn first. Defaults to 7.\n\n\ntitleNone, str\n\n\nused to draw the figure title, if specified (str). Forwarded to different plot types.\n\n\naxNone, matplotlib.axes.Axes\n\n\nIf None a new matplotlib figure will be created. If ax inherits from matplotlib.axes.Axes this object will be used to create the demoplot. Handy to create multiple subplots. Forwarded to different plot types.\n\n\n**kwargs\n\n\nForwarded to the corresponding demo plot functions.\n\n\n\n\nExamples\n\n# Importing modules\nfrom colorspace import *\nfrom colorspace.colorlib import *\n# Custom list of hex colors (n = 5)\nhexlist    = [\"#BCBE57\", \"#DEDFC0\", \"#F1F1F1\", \"#F7D3E7\", \"#FB99D7\"]\nhexlist\n\n['#BCBE57', '#DEDFC0', '#F1F1F1', '#F7D3E7', '#FB99D7']\n\n\n\n# A (HCL based) colorobject with (n = 3)\ncolorobj = HCL([0, 90, 180], [60, 60, 60], [60, 60, 60])\ncolorobj\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:    0.00   60.00   60.00\n       90.00   60.00   60.00\n      180.00   60.00   60.00\n\n\n\n# Default diverging HCL palette\nhclpalette = diverging_hcl()\nhclpalette\n\n&lt;colorspace.palettes.diverging_hcl at 0x7f1a571a47d0&gt;\n\n\n\n# Default color palette shipped with the package\nberlin = hcl_palettes(name = \"Berlin\").get_palettes()[0]\nberlin\n\nPalette Name: Berlin\n        Type: Advanced: Diverging\n        Inspired by: Crameri's sico palettes\n         c1            60\n         cmax          80\n         fixup       True\n         gui            1\n         h1           240\n         h2            15\n         l1            75\n         l2             5\n         p1           1.2\n         p2           1.5\n\n\n\n# Demoplots\ndemoplot(hexlist, \"Bar\");\n\n\n\n\n\n\n\n\n\ndemoplot(colorobj, \"Lines\");\n\n\n\n\n\n\n\n\n\ndemoplot(hclpalette, \"Pie\", n = 4);\n\n\n\n\n\n\n\n\n\ndemoplot(berlin.colors(), \"Matrix\", n = 11);\n\n\n\n\n\n\n\n\n\n# Using custom subplots and plot titles\nfrom matplotlib import pyplot as plt\nfrom colorspace import protan, deutan, desaturate\nfig, axes = plt.subplots(2, 2)\ncolors = diverging_hcl(\"Green-Orange\").colors(7)\ndemoplot(colors, \"Bar\",\n         title = \"Original\", ax = axes[0, 0]);\ndemoplot(protan(colors), \"Bar\",\n         title = \"Protanope vision\", ax = axes[0, 1]);\ndemoplot(deutan(colors), \"Bar\",\n         title = \"Deuteranope vision\", ax = axes[1, 0]);\ndemoplot(desaturate(colors), \"Bar\",\n         title = \"Desaturated\", ax = axes[1, 1]);\nplt.show()\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If type_ is not a str.\n\nValueError: If type_ is not an available demo plot type.\n\nTypeError: If n is not int.\n\nValueError: n must be a positive int.",
    "crumbs": [
      "Home",
      "Function references",
      "demoplot"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.show_settings.html",
    "href": "man/colorspace.palettes.terrain_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\nterrain_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.specplot.html",
    "href": "man/colorspace.palettes.diverging_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\ndiverging_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.length.html",
    "href": "man/colorspace.colorlib.hexcols.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nhexcols.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.swatchplot.html",
    "href": "man/colorspace.colorlib.polarLAB.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\npolarLAB.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.colors.html",
    "href": "man/colorspace.colorlib.CIEXYZ.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nCIEXYZ.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.show_settings.html",
    "href": "man/colorspace.palettes.rainbow.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\nrainbow.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.colors.html",
    "href": "man/colorspace.palettes.rainbow_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\nrainbow_hcl.colors(n=11, fixup=None, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned, defaults to 11.\n\n\nfixupNone, bool\n\n\nshould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\n**kwargs\n\n\nIf any colorobject = argument is specified, HCL colors will be returned."
  },
  {
    "objectID": "man/colorspace.palettes.palette.html",
    "href": "man/colorspace.palettes.palette.html",
    "title": "Custom Color Palette",
    "section": "",
    "text": "Description\nAllows for the construction of custom (named) color palettes with a fixed set of colors based on hex color inputs.\n\n\nUsage\npalette(colors, name=None, n=7)\n\n\nArguments\n\n\ncolorsstr, list, colorspace.colorlib.colorobject\n\n\nOne or multiple colors which will make up the custom palette.\n\n\nnamestr\n\n\nName of this custom palette. Defaults to \"user_palette\". Used for object representation/visualization.\n\n\nnint\n\n\npositive int, number of colors drawn from an hclpalette object. Only taken into account if the object provided on colors inherits from colorspace.palettes.hclpalette.\n\n\n\n\nReturn\nAn object of class colorspace.palettes.palette.\n\n\nMethods\n\n\npalette.cmap(n=None, rev=False)\n\n\nGet matplotlib Compatible Color Map\n\n\npalette.colors(*args, **kwargs)\n\n\nGet Palette Colors\n\n\npalette.name()\n\n\nGet Palette Name\n\n\npalette.rename(name)\n\n\nRename Custom Palette\n\n\npalette.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace.palettes import palette\ncolors = [\"#070707\", \"#690056\", \"#C30E62\", \"#ED8353\", \"#FDF5EB\"]\ncustom_pal = palette(colors, \"test palette\")\ncustom_pal\n\nPalette Name: test palette\n       Type: Custom palette\n       Number of colors: 5\n\n\n\n# Creating custom palettes based on different input\n# types (str, list, colorobject)\nfrom colorspace.colorlib import hexcols\nfrom colorspace import palette\nhexcols = hexcols(colors)\n\n# Creating a series of custom palette objects\npal1 = palette(\"#ff0033\") # unnamed\npal2 = palette(\"#ff0033\", name = \"Custom Palette\")\npal3 = palette(colors,  name = \"Custom Palette #3\")\npal4 = palette(hexcols, name = \"Custom Palette #4\")\nprint(pal1)\n\nPalette Name: None\n       Type: Custom palette\n       Number of colors: 1\n\n\n\n\nprint(pal2)\n\nPalette Name: Custom Palette\n       Type: Custom palette\n       Number of colors: 1\n\n\n\n\nprint(pal3)\n\nPalette Name: Custom Palette #3\n       Type: Custom palette\n       Number of colors: 5\n\n\n\n\nprint(pal4)\n\nPalette Name: Custom Palette #4\n       Type: Custom palette\n       Number of colors: 5\n\n\n\n\n# Palette Swatch Plot\nfrom colorspace import swatchplot\nswatchplot([pal3, pal4], figsize = (5.5, 2.0));",
    "crumbs": [
      "Home",
      "Class references",
      "palette"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.html",
    "href": "man/colorspace.palettes.divergingx_hcl.html",
    "title": "Diverging X HCL Color Palettes",
    "section": "",
    "text": "Description\nSee also: qualitative_hcl, sequential_hcl, diverging_hcl, rainbow_hcl, heat_hcl, terrain_hcl, diverging_hsv, and rainbow.\n\n\nUsage\ndivergingx_hcl(h=[192, 77, 21], c=[40, 35, 100],               l=[50, 95, 50],               power=[1.0, 1.0, 1.2, 1.0], cmax=20,               fixup=True, palette=None, rev=False,               *args, **kwargs)\n\n\nArguments\n\n\nhlist of float or int\n\n\nHue values (color), divergingx color palettes should have different hues for both ends and the center of the palette. For this class three values must be provided. If input h is a str this argument acts like the palette argument (see palette input parameter).\n\n\nclist of float or int\n\n\nChroma value (colorfullness), list of floats. In case two values are provided the firt is taken as c1 and c3 while the second one is used for c2 (center value). When three or more are provided the first three are used for c1, c2, and c3. cmax1 and cmax2 have to provided as extra arguments.\n\n\nllist of float or int\n\n\nluminance values (lightness). In case two values are provided the firt is taken as c1 and c3 while the second one is used for c2 (center value). When three or more are provided the first three are used for c1, c2, and c3. cmax1 and cmax2 have to provided as extra arguments.\n\n\npowerlist of float\n\n\nPower parameters for non-linear behaviour of the color palette. Up to four values can be provided for p1, p2, p3, p4. If two values are provided power[0] will be used for p1 and p4 while power[1] is used for p2 and p3 (symmetric).\n\n\ncmaxlist of float or int\n\n\nMaximum chroma. If one value is provided this will be used for both, cmax1 and cmax2. Else the first two elements will be used for cmax1 and cmax2 respectively.\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\npalettestr\n\n\nCan be used to load a default diverging color palette specification. If the palette does not exist an exception will be raised. Else the settings of the palette as defined will be used to create the color palette.\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nCurrently unused.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings. @TODO has to be documented.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\ndivergingx_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\ndivergingx_hcl.colors(n=11, fixup=True, alpha=None, **kwargs)\n\n\nGet Colors\n\n\ndivergingx_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\ndivergingx_hcl.name()\n\n\nGet Palette Name\n\n\ndivergingx_hcl.show_settings()\n\n\nShow Palette Settings\n\n\ndivergingx_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\ndivergingx_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\na = diverging_hcl()\na.colors(10)\n\n['#023FA5',\n '#6371AF',\n '#959CC3',\n '#BEC1D4',\n '#DBDCE0',\n '#E0DBDC',\n '#D6BCC0',\n '#C6909A',\n '#AE5A6D',\n '#8E063B']\n\n\n\n# Different color palette by name\nb = diverging_hcl(\"Blue-Yellow 3\")\nb.colors(10)\n\n['#9FA2FF',\n '#BCBFFF',\n '#D3D5FF',\n '#E3E4FF',\n '#ECEDFF',\n '#F6F1CE',\n '#F2EBAC',\n '#E7DD87',\n '#D4C958',\n '#BAAE00']\n\n\n\nb.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\ndiverging_hcl(\"Temps\")(10)\n\n['#089392',\n '#2DA7A6',\n '#46BCBB',\n '#5DD1D0',\n '#75E7E6',\n '#DFD792',\n '#CAC27D',\n '#B5AD6A',\n '#A09957',\n '#8C8545']",
    "crumbs": [
      "Home",
      "Class references",
      "divergingx_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.to.html",
    "href": "man/colorspace.colorlib.CIELAB.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nCIELAB.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.XYZ_to_uv.html",
    "href": "man/colorspace.colorlib.colorlib.XYZ_to_uv.html",
    "title": "Convert CIEXYZ to u and v",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.XYZ_to_uv(X, Y, Z)\n\n\nArguments\n\n\nXnumpy.ndarray\n\n\nValues for the Z dimension.\n\n\nYnumpy.ndarray\n\n\nValues for the Y dimension.\n\n\nZnumpy.ndarray\n\n\nValues for the Z dimension.\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays ([u, v])."
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.length.html",
    "href": "man/colorspace.colorlib.HLS.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nHLS.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.sRGB_to_HLS.html",
    "href": "man/colorspace.colorlib.colorlib.sRGB_to_HLS.html",
    "title": "Convert Standard RGB (sRGB) to HLS",
    "section": "",
    "text": "Description\nAll r/g/b values in [0., 1.], h in [0., 360.], l and s in [0., 1.]. From: http://wiki.beyondunreal.com/wiki/RGB_To_HLS_Conversion.\n\n\nUsage\ncolorlib.sRGB_to_HLS(r, g, b)\n\n\nArguments\n\n\nrnumpy.ndarray\n\n\nIntensities for red ([0., 1.])\n\n\ngnumpy.ndarray\n\n\nIntensities for green ([0., 1.])\n\n\nbnumpy.ndarray\n\n\nIntensities for blue ([0., 1.])\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays with the corresponding coordinates in the HLS color space ([h, l, s]). Same length as the inputs."
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.html",
    "href": "man/colorspace.palettes.heat_hcl.html",
    "title": "HCL Based Heat Color Palette",
    "section": "",
    "text": "Description\nHeat hcl, a sequential HCL color palette.\nSee also: qualitative_hcl, sequential_hcl, diverging_hcl, divergingx_hcl, rainbow_hcl, terrain_hcl, diverging_hsv, and rainbow.\n\n\nUsage\nheat_hcl(h=[0, 90], c=[100, 30], l=[50, 90],         power=[0.2, 1.0], fixup=True, rev=False,         *args, **kwargs)\n\n\nArguments\n\n\nhlist of int\n\n\nHue parameters (h1/h2).\n\n\nclist of int\n\n\nChroma parameters (c1/c2).\n\n\nlint\n\n\nLuminance parameters (l1/l2).\n\n\npowerlist of float\n\n\nPower parameters (p1/p2).\n\n\ngammafloat\n\n\nGamma value used for transfiromation from/to sRGB. @TODO implemented? Check!\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nCurrently unused.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\nheat_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\nheat_hcl.colors(n=11, fixup=True, **kwargs)\n\n\nGet Colors\n\n\nheat_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\nheat_hcl.name()\n\n\nGet Palette Name\n\n\nheat_hcl.show_settings()\n\n\nShow Palette Settings\n\n\nheat_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\nheat_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace.palettes import heat_hcl\npal = heat_hcl()\npal.colors(3)\n\n['#D33F6A', '#E99A2C', '#E2E6BD']\n\n\n\npal.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\nheat_hcl()(10)\n\n['#D33F6A',\n '#DA565E',\n '#E06B50',\n '#E57E41',\n '#E89132',\n '#EAA428',\n '#E9B62D',\n '#E8C842',\n '#E5D961',\n '#E2E6BD']",
    "crumbs": [
      "Home",
      "Class references",
      "heat_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.colors.html",
    "href": "man/colorspace.colorlib.hexcols.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nhexcols.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.to.html",
    "href": "man/colorspace.colorlib.polarLAB.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\npolarLAB.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.name.html",
    "href": "man/colorspace.palettes.sequential_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\nsequential_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.html",
    "href": "man/colorspace.colorlib.polarLAB.html",
    "title": "Create Polar LAB Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the polar representation of the CIELAB color space. Can be converted to: CIEXYZ, CIELUV, CIELAB, RGB, sRGB, polarLAB, and hexcols. Not allowed (ambiguous) are transformations to HSV and HLS.\n\n\nUsage\npolarLAB(L, A, B, alpha=None)\n\n\nArguments\n\n\nLint, float, list, numpy.array\n\n\nNumeric value(s) for L dimension.\n\n\nAint, float, list, numpy.array\n\n\nNumeric value(s) for A dimension.\n\n\nBint, float, list, numpy.array\n\n\nNumeric value(s) for B dimension.\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\npolarLAB.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\npolarLAB.dropalpha()\n\n\nRemove Alpha Channel\n\n\npolarLAB.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\npolarLAB.get_whitepoint()\n\n\nGet White Point\n\n\npolarLAB.hasalpha()\n\n\nCheck for Alpha Channel\n\n\npolarLAB.length()\n\n\nGet Number of Colors\n\n\npolarLAB.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\npolarLAB.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\npolarLAB.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\npolarLAB.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\npolarLAB.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace import polarLAB\ncols = polarLAB([50, 80, 30], [100, 120, 140], [40, 130, 300])\ncols\n\npolarLAB color object (3 colors)\n           L       A       B\n  1:   50.00  100.00   40.00\n       80.00  120.00  130.00\n       30.00  140.00  300.00\n\n\n\n# Convert to hex colors\ncols.to(\"hex\")\ncols\n\nhexcols color object (3 colors)\n        hex_\n  1:b'#F00000'\n    b'#3AE500'\n    b'#0027FF'",
    "crumbs": [
      "Home",
      "Class references",
      "polarLAB"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.specplot.html",
    "href": "man/colorspace.colorlib.polarLUV.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\npolarLUV.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.polarLAB_to_LAB.html",
    "href": "man/colorspace.colorlib.colorlib.polarLAB_to_LAB.html",
    "title": "Convert polarLAB to CIELAB",
    "section": "",
    "text": "Description\nConvert colors from the polar representation of the CIELAB color space into CIELAB coordinates. Inverse function of :py:meth:LAB_to_polarLAB.\n\n\nUsage\ncolorlib.polarLAB_to_LAB(L, C, H)\n\n\nArguments\n\n\nWARNING(missing argument definition “C” in docstring)\n\n\nWARNING(missing argument definition “H” in docstring)\n\n\n\n\nLnumpy.ndarray\n\n\nValues for the polar L dimension.\n\n\nAnumpy.ndarray\n\n\nValues for the polar A dimension.\n\n\nBnumpy.ndarray\n\n\nValues for the polar B dimension."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.XYZ_to_RGB.html",
    "href": "man/colorspace.colorlib.colorlib.XYZ_to_RGB.html",
    "title": "Convert CIEXYZ to RGB",
    "section": "",
    "text": "Description\nX, Y, and Z specify the values in the three coordinates of the CIEXYZ color space, XN, YN, and ZN allow to specify additional CIE chromaticities to specify a specific white point.\n\n\nUsage\ncolorlib.XYZ_to_RGB(X, Y, Z, XN=None, YN=None,                    ZN=None)\n\n\nArguments\n\n\nXnumpy.ndarray\n\n\nValues for the X dimension.\n\n\nYnumpy.ndarray\n\n\nValues for the Y dimension.\n\n\nZnumpy.ndarray\n\n\nValues for the Z dimension.\n\n\nXNNone, numpy.ndarray\n\n\nChromaticity of the white point. If of length 1, the white point specification will be recycled if needed. When not specified (all None) a default white point is used.\n\n\nYN\n\n\nSee XN.\n\n\nZN\n\n\nSee XN.\n\n\n\n\nReturn\nReturns corresponding coordinates as a list of numpy.ndarrays of the same length as the inputs ([R, G, B])."
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.set_whitepoint.html",
    "href": "man/colorspace.colorlib.hexcols.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nhexcols.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.specplot.html",
    "href": "man/colorspace.colorlib.CIELAB.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nCIELAB.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.show_settings.html",
    "href": "man/colorspace.palettes.diverging_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\ndiverging_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.hasalpha.html",
    "href": "man/colorspace.colorlib.hexcols.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nhexcols.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.utils.adjust_transparency.html",
    "href": "man/colorspace.utils.adjust_transparency.html",
    "title": "Adjust Alpha Channel",
    "section": "",
    "text": "Description\nAllows to set, adjust, or remove transparency (alpha channel). In case alpha is a single float, a constant transparency will be added to all colors. If alpha is a list or numpy.ndarray it must be the same length as the number of colors in the object x and all values must be convertable to float/int in the range of [0., 1.]. Allows to add individual transparency for each color in x.\n\n\nUsage\nadjust_transparency(x, alpha)\n\n\nArguments\n\n\nx\n\n\nsequence of colors; an object which inherits from colorsspace.colorlib.colorobject.\n\n\nalphaNone, float, int, list, numpy.ndarray\n\n\nNone will remove existing transparency (if existing). If float, list, or numpy.ndarray` trnasparency will be added. See function description for more details.\n\n\n\n\nReturn\nnumpy.ndarray or None: None if the colorobject has no defined transparency, else a numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace import *\nfrom colorspace.colorlib import hexcols\nimport numpy as np\n# Three colors without transparency\ncols1 = ['#023FA5',   '#E2E2E2',   '#8E063B']\n# Same colors as in `cols1` with transparency of 80%, 40%, 80%\ncols2 = ['#023FA5CC', '#E2E2E266', '#8E063BCC']\n\n# Converting list of hex colors `cols1` into `hexcolor` objects\nx1 = hexcols(cols1)\nx1\n\nhexcols color object (3 colors)\n        hex_\n  1:b'#023FA5'\n    b'#E2E2E2'\n    b'#8E063B'\n\n\n\n# Extract transparency\nextract_transparency(x1) # Returns 'None' (no transparency)\n\n\n# `x1`: Setting constant transparency of 0.5 for all colors\nadjust_transparency(x1, 0.5)\n\nhexcols color object (3 colors)\n        hex_   alpha\n  1:b'#023FA5'    7F\n    b'#E2E2E2'    7F\n    b'#8E063B'    7F\n\n\n\n# Setting custom transparency (adjusting; overwrite existing 0.5)\nadjust_transparency(x1, [0.7, 0.3, 0.7]) # Add transparency\n\nhexcols color object (3 colors)\n        hex_   alpha\n  1:b'#023FA5'    B2\n    b'#E2E2E2'    4C\n    b'#8E063B'    B2\n\n\n\n# Converting list of hex colors `cols2` into `hexcolor` objects\n# and extract transparency defined via 8 digit hex color str\nx2 = hexcols(cols2)\nextract_transparency(x2)\n\narray([0.8, 0.4, 0.8])\n\n\n\n# Removing transparency, extracting new values (None)\nx2 = adjust_transparency(x2, None)\nextract_transparency(x2) # Returns 'None' (no transparency)\n\n\n# Adding transparency again\nx2 = adjust_transparency(x2, np.asarray([0.8, 0.4, 0.8]))\nx2\n\nhexcols color object (3 colors)\n        hex_   alpha\n  1:b'#023FA5'    CC\n    b'#E2E2E2'    66\n    b'#8E063B'    CC\n\n\n\nextract_transparency(x2)\n\narray([0.8, 0.4, 0.8])\n\n\n\n\nRaises\n\n\nTypeError: If input object does not inherit from colorspace.colorlib.colorobject.\n\nTypeError: If alpha is not one of the expected types.",
    "crumbs": [
      "Home",
      "Function references",
      "adjust_transparency"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.hclpalettes.get_palettes.html",
    "href": "man/colorspace.palettes.hclpalettes.get_palettes.html",
    "title": "Get Type-Specific Palettes",
    "section": "",
    "text": "Description\nGet all palettes of a specific type.\n\n\nUsage\nhclpalettes.get_palettes(type_=None)\n\n\nArguments\n\n\ntype_None, str\n\n\n(Partial) Name of the palettes which should be returned. String matching is used; partial matches are allowed. If set to None (default) all palettes will be returned. Names have to match but are not case sensitive, defaults to None.\n\n\n\n\nReturn\nReturns a list containing defaultpalette objects objects."
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.heat_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nheat_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.html",
    "href": "man/colorspace.colorlib.HLS.html",
    "title": "Create HLS Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the Hue-Lightness-Saturation (HLS) color space. Can be converted to: RGB, sRGB, HSV, and hexcols. Not allowed (ambiguous) are transformations to CIEXYZ, CIELUV, CIELAB, polarLUV, and polarLAB.\n\n\nUsage\nHLS(H, L, S, alpha=None)\n\n\nArguments\n\n\nHint, float, list, numpy.array\n\n\nNumeric value(s) for Hue dimension.\n\n\nLint, float, list, numpy.array\n\n\nNumeric value(s) for Lightness dimension.\n\n\nSint, float, list, numpy.array\n\n\nNumeric value(s) for Saturation dimension.\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\nHLS.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nHLS.dropalpha()\n\n\nRemove Alpha Channel\n\n\nHLS.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nHLS.get_whitepoint()\n\n\nGet White Point\n\n\nHLS.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nHLS.length()\n\n\nGet Number of Colors\n\n\nHLS.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nHLS.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nHLS.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nHLS.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nHLS.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HLS\n# Constructing color object with one single color via float\nHLS(150, 0.1, 3)\n\nHLS color object (1 colors)\n           H       L       S\n  1:  150.00    0.10    3.00\n\n\n\n# Constructing object via lists\nHLS([150, 0, 10], [0.1, 0.7, 0.1], [3, 0, 3])\n\nHLS color object (3 colors)\n           H       L       S\n  1:  150.00    0.10    3.00\n        0.00    0.70    0.00\n       10.00    0.10    3.00\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\ncols = HLS(asarray([150, 0, 10]),\n           asarray([0.1, 0.7, 0.1]),\n           asarray([3, 0, 3]))\ncols\n\nHLS color object (3 colors)\n           H       L       S\n  1:  150.00    0.10    3.00\n        0.00    0.70    0.00\n       10.00    0.10    3.00\n\n\n\n# Converting to RGB\ncols.to(\"RGB\")\ncols\n\nRGB color object (3 colors)\n           R       G       B\n  1:   -0.02    0.13    0.01\n        0.45    0.45    0.45\n        0.13   -0.01   -0.02",
    "crumbs": [
      "Home",
      "Class references",
      "HLS"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.name.html",
    "href": "man/colorspace.palettes.diverging_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\ndiverging_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.to.html",
    "href": "man/colorspace.colorlib.HSV.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nHSV.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.set_whitepoint.html",
    "href": "man/colorspace.colorlib.RGB.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nRGB.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.html",
    "href": "man/colorspace.palettes.rainbow_hcl.html",
    "title": "HCL Based Rainbow Palette",
    "section": "",
    "text": "Description\nHCL rainbow, a qualitative cyclic rainbow color palette with uniform luminance and chroma.\nSee also: qualitative_hcl, sequential_hcl, diverging_hcl, divergingx_hcl, heat_hcl, terrain_hcl, diverging_hsv, and rainbow.\n\n\nUsage\nrainbow_hcl(c=50, l=70, start=0,            end=&lt;function rainbow_hcl.&lt;lambda&gt; at 0x7b1b25c7fe20&gt;,            gamma=None, fixup=True, rev=False,            *args, **kwargs)\n\n\nArguments\n\n\ncint\n\n\nChroma (colorfullness) of the color map [0-100+].\n\n\nlint\n\n\nLuminance (lightness) of the color map [0-100].\n\n\nstartint, lambda\n\n\nHue at which the rainbow should start or lambda function with one argument. Defaults to 0.\n\n\nendint, lambda\n\n\nHue (int) at which the rainbow should end or lambda function with one argument. By default a lambda function evaluated when drawing colors (360 * (n - 1) / n).\n\n\ngammafloat\n\n\nGamma value used for transfiromation from/to sRGB. @TODO implemented? Check!\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\nrevbool\n\n\nShould the color map be reversed? Default False.\n\n\n*args\n\n\nCurrently unused.\n\n\n**kwargs\n\n\nProcessed internally; can be used to overwrite h1, h2, c1, l1, l2 and p1.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\nrainbow_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\nrainbow_hcl.colors(n=11, fixup=None, **kwargs)\n\n\nGet Colors\n\n\nrainbow_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\nrainbow_hcl.name()\n\n\nGet Palette Name\n\n\nrainbow_hcl.show_settings()\n\n\nShow Palette Settings\n\n\nrainbow_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\nrainbow_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import rainbow_hcl\npal = rainbow_hcl()\npal.colors(10)\n\n['#E495A5',\n '#D89F7F',\n '#BDAB66',\n '#96B56C',\n '#65BC8C',\n '#39BEB1',\n '#55B8D0',\n '#91ACE1',\n '#C29DDE',\n '#DE94C8']\n\n\n\npal.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors. Thus,\n# you can make your code slimmer by calling\nrainbow_hcl()(10)\n\n['#E495A5',\n '#D89F7F',\n '#BDAB66',\n '#96B56C',\n '#65BC8C',\n '#39BEB1',\n '#55B8D0',\n '#91ACE1',\n '#C29DDE',\n '#DE94C8']\n\n\n\n# Testing lambda function for both, start and end\npal = rainbow_hcl(start = lambda n: (n - 1) / n,\n                  end = lambda n: 360 - (n - 1) / n)\npal(5)\n\n['#E495A4', '#AAB065', '#39BEB1', '#ABA4E2', '#E495A6']\n\n\n\npal(11)\n\n['#E495A4',\n '#D79F7E',\n '#BCAB66',\n '#95B56D',\n '#64BC8C',\n '#39BEB1',\n '#55B8D0',\n '#90ACE1',\n '#C19DDE',\n '#DD94C8',\n '#E495A6']",
    "crumbs": [
      "Home",
      "Class references",
      "rainbow_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.name.html",
    "href": "man/colorspace.palettes.diverging_hsv.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\ndiverging_hsv.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.hasalpha.html",
    "href": "man/colorspace.colorlib.polarLUV.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\npolarLUV.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.get_whitepoint.html",
    "href": "man/colorspace.colorlib.polarLUV.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\npolarLUV.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.XYZ_to_LAB.html",
    "href": "man/colorspace.colorlib.colorlib.XYZ_to_LAB.html",
    "title": "Convert CIEXYZ to CIELAB",
    "section": "",
    "text": "Description\nX, Y, and Z specify the values in the three coordinates of the CIELAB color space, XN, YN, and ZN allow to specify additional CIE chromaticities to specify a specific white point.\n\n\nUsage\ncolorlib.XYZ_to_LAB(X, Y, Z, XN=None, YN=None,                    ZN=None)\n\n\nArguments\n\n\nXnumpy.ndarray\n\n\nValues for the X dimension.\n\n\nYnumpy.ndarray\n\n\nValues for the Y dimension.\n\n\nZnumpy.ndarray\n\n\nValues for the Z dimension.\n\n\nXNNone, numpy.ndarray\n\n\nChromaticity of the white point. If of length 1, the white point specification will be recycled if needed. When not specified (all None) a default white point is used.\n\n\nYN\n\n\nSee XN.\n\n\nZN\n\n\nSee XN.\n\n\n\n\nReturn\nReturns corresponding coordinates of CIE chromaticities as a list of numpy.ndarrays of the same length as the inputs ([L, A, B])."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.set_whitepoint.html",
    "href": "man/colorspace.colorlib.polarLAB.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\npolarLAB.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.get.html",
    "href": "man/colorspace.colorlib.HLS.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nHLS.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.get_whitepoint.html",
    "href": "man/colorspace.colorlib.RGB.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nRGB.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.set.html",
    "href": "man/colorspace.colorlib.CIEXYZ.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nCIEXYZ.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.swatchplot.html",
    "href": "man/colorspace.colorlib.HLS.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nHLS.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.length.html",
    "href": "man/colorspace.colorlib.CIEXYZ.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nCIEXYZ.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.specplot.html",
    "href": "man/colorspace.colorlib.CIELUV.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nCIELUV.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.html",
    "href": "man/colorspace.palettes.diverging_hcl.html",
    "title": "Diverging HCL Color Palettes",
    "section": "",
    "text": "Description\nSee also: qualitative_hcl, sequential_hcl, divergingx_hcl, rainbow_hcl, heat_hcl, terrain_hcl, diverging_hsv, and rainbow.\n\n\nUsage\ndiverging_hcl(h=[260, 0], c=80, l=[30, 90],              power=1.5, fixup=True, palette=None,              rev=False, *args, **kwargs)\n\n\nArguments\n\n\nhlist of numerics\n\n\nHue values (color), diverging color palettes should have different hues for both ends of the palette. If only one value is present it will be recycled ending up in a diverging color palette with the same colors on both ends. If more than two values are provided the first two will be used while the rest is ignored. If input h is a str this argument acts like the palette argument (see palette input parameter).\n\n\ncnumeric\n\n\nChroma value (colorfullness), a single numeric value. If two values are provided the first will be taken as c1, the second as cmax.\n\n\nllist of numerics\n\n\nluminance values (lightness). The first value is for the two ends of the color palette, the second one for the neutral center point. If only one value is given this value will be recycled.\n\n\npowerfloat\n\n\nPower parameter for non-linear behaviour of the color palette.\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\npalettestr\n\n\nCan be used to load a default diverging color palette specification. If the palette does not exist an exception will be raised. Else the settings of the palette as defined will be used to create the color palette.\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nCurrently unused.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings. @TODO has to be documented.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\ndiverging_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\ndiverging_hcl.colors(n=11, fixup=True, alpha=None, **kwargs)\n\n\nGet Colors\n\n\ndiverging_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\ndiverging_hcl.name()\n\n\nGet Palette Name\n\n\ndiverging_hcl.show_settings()\n\n\nShow Palette Settings\n\n\ndiverging_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\ndiverging_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\na = diverging_hcl()\na.colors(10)\n\n['#023FA5',\n '#6371AF',\n '#959CC3',\n '#BEC1D4',\n '#DBDCE0',\n '#E0DBDC',\n '#D6BCC0',\n '#C6909A',\n '#AE5A6D',\n '#8E063B']\n\n\n\n# Different color palette by name\nb = diverging_hcl(\"Tropic\")\nb.colors(10)\n\n['#009B9F',\n '#00ADB1',\n '#6CC0C2',\n '#A7D3D5',\n '#D9E7E7',\n '#EDE1E8',\n '#E4C1D8',\n '#DBA1C8',\n '#D180B9',\n '#C75DAA']\n\n\n\nb.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\ndiverging_hcl(\"Tropic\")(10)\n\n['#009B9F',\n '#00ADB1',\n '#6CC0C2',\n '#A7D3D5',\n '#D9E7E7',\n '#EDE1E8',\n '#E4C1D8',\n '#DBA1C8',\n '#D180B9',\n '#C75DAA']",
    "crumbs": [
      "Home",
      "Class references",
      "diverging_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.length.html",
    "href": "man/colorspace.colorlib.RGB.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nRGB.length()"
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.colors.html",
    "href": "man/colorspace.palettes.heat_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\nheat_hcl.colors(n=11, fixup=True, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned.\n\n\nfixupNone, bool\n\n\nShould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return."
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.colors.html",
    "href": "man/colorspace.palettes.sequential_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\nsequential_hcl.colors(n=11, fixup=True, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned.\n\n\nfixupNone, bool\n\n\nShould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.LAB_to_polarLAB.html",
    "href": "man/colorspace.colorlib.colorlib.LAB_to_polarLAB.html",
    "title": "Convert CIELAB to the polar representation (polarLAB)",
    "section": "",
    "text": "Description\nConverts colors from the CIELAB color space into its polar representation (polarLAB). Inverse function of :py:meth:polarLAB_to_LAB.\n\n\nUsage\ncolorlib.LAB_to_polarLAB(L, A, B)\n\n\nArguments\n\n\nLnumpy.ndarray\n\n\nValues for the L dimension.\n\n\nAnumpy.ndarray\n\n\nValues for the A dimension.\n\n\nBnumpy.ndarray\n\n\nValues for the B dimension.\n\n\n\n\nReturn\nReturns corresponding polar LAB chromaticities as a list of numpy.ndarrays of the same length as the inputs ([L, A, B])."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.hasalpha.html",
    "href": "man/colorspace.colorlib.polarLAB.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\npolarLAB.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.colors.html",
    "href": "man/colorspace.colorlib.HSV.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nHSV.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.specplot.html",
    "href": "man/colorspace.palettes.rainbow.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nrainbow.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.name.html",
    "href": "man/colorspace.palettes.terrain_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\nterrain_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.swatchplot.swatchplot.html",
    "href": "man/colorspace.swatchplot.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization of color palettes in columns of color swatches. The first argument pals is very flexible and can be:\n\nList of hex colors,\na single object which inherits from colorspace.palettes.palette, colorspace.palettes.hclpalette, colorspace.colorlib.colorobject,\na list of objects listed above (all of the same type or mixed),\na dictionary with lists of objects as above. If a dictionary is used the keys of the dictionary are used as ‘subtitles’ to group sets of palettes,\nan object of class colorspace.palettes.hclpalettes,\nor an object of class matplotlib.colors.LinearSegmentedColormap.\n\nRequires the matplotlib to be installed.\n\n\nUsage\nswatchplot(pals, show_names=True, nrow=20, n=5,           cvd=None, **kwargs)\n\n\nArguments\n\n\npals\n\n\nThe color palettes or color objects to be visualized. See description for details and examples to demonstrate different usages.\n\n\nshow_namesbool\n\n\nShould palette names be shown (if available), defaults to True.\n\n\nnrowint\n\n\nMaximum number of rows of swatches, defaults to 20.\n\n\nnint\n\n\nNumber of colors to be drawn from palette objects, defaults to 5.\n\n\ncvdNone or list\n\n\nAllows to display one or multiple palettes and how they look with emulated color vision deficiencies. If None, this is not applied. Can be set to a list of characters. Allowed: \"protan\", \"tritan\", \"deutan\", \"desaturate\" corresponding to the functions protan, tritan, deutan, desaturate.\n\n\n**kwargs\n\n\nforwarded to matplotlib.pyplot.subplot, can be used to control e.g., figsize.\n\n\n\n\nExamples\n\nfrom colorspace import swatchplot, palette\nfrom colorspace import sequential_hcl, diverging_hcl, heat_hcl\n# List of hex colors\nswatchplot(['#7FBFF5', '#2A4962', '#111111', '#633C39', '#F8A29E'],\n           figsize = (7, 0.5));\n\n\n\n\n\n\n\n\n\n# Create a custom 'palette' (named):\npal = palette(['#7FBFF5', '#2A4962', '#111111', '#633C39', '#F8A29E'],\n              \"Custom Named Palette\")\nswatchplot(pal, figsize = (7, 0.5));\n\n\n\n\n\n\n\n\n\n# A HCL palette. 'n' defines the number of colors.\nswatchplot(sequential_hcl(\"PuBu\"), n = 10,\n           figsize = (7, 0.5));\n\n\n\n\n\n\n\n\n\n# Combine all three\nswatchplot([['#7FBFF5', '#2A4962', '#111111', '#633C39', '#F8A29E'],\n            pal, sequential_hcl(\"PuBu\")], n = 7,\n            figsize = (7, 1.5));\n\n\n\n\n\n\n\n\n\n# A color object (e.g., RGB, HCL, CIELUV, ...)\nfrom colorspace.colorlib import hexcols\ncobject  = hexcols(heat_hcl()(5))\ncobject.to(\"HCL\")\nprint(cobject)\n\npolarLUV color object (5 colors)\n           H       C       L\n  1:  359.96  100.56   50.04\n       22.73   95.68   60.00\n       44.77   91.06   69.91\n       67.39   82.91   79.91\n       90.40   29.80   90.06\n\n\n\nswatchplot(cobject, figsize = (7, 0.5));\n\n\n\n\n\n\n\n\n\n# Using dictionaries to add subtitles\n# to 'group' different palettes.\nswatchplot({\"Diverging\": [diverging_hcl(), diverging_hcl(\"Red-Green\")],\n            \"Sequential\": [sequential_hcl(\"ag_Sunset\"), sequential_hcl(\"OrRd\")],\n            \"Others\": [['#7FBFF5', '#2A4962', '#111111', '#633C39', '#F8A29E'],\n                       pal, sequential_hcl(\"PuBu\")]}, n = 15);\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If nrow or n no int.\n\nTypeError: If show_names not bool.\n\nValueError: If nrow or n are not positive.\n\nImportError: If matplotlib.pyplot cannot be imported, maybe matplotlib not installed?",
    "crumbs": [
      "Home",
      "Function references",
      "swatchplot"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.hasalpha.html",
    "href": "man/colorspace.colorlib.CIEXYZ.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nCIEXYZ.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.get.html",
    "href": "man/colorspace.colorlib.CIELUV.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nCIELUV.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.swatchplot.html",
    "href": "man/colorspace.colorlib.hexcols.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nhexcols.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.utils.max_chroma.html",
    "href": "man/colorspace.utils.max_chroma.html",
    "title": "Compute Maximum Chroma for Given Hue and Luminance in HCL",
    "section": "",
    "text": "Description\nCompute approximately the maximum chroma possible for a given hue and luminance combination in the HCL color space.\nH and L can be single values or multiple values. If both have length &gt; 1, the length must match. If one is of length 1 it will be recycled to match the length of the other argument. In case the function is not able to create two arrays of the same length an error will be thrown.\n\n\nUsage\nmax_chroma(H, L, floor=False)\n\n\nArguments\n\n\nHint, float, list, numpy.ndarray\n\n\nhue, one or multiple values (must be convertable to float).\n\n\nLint, float, list, numpy.ndarray\n\n\nluminance, one or multiple values (must be convertable to float).\n\n\nfloorbool\n\n\nshould return be rounded? Defaults to False.\n\n\n\n\nReturn\nArray of the same length as max(len(H), len(L)) with maximum possible chroma for these hue-luminance combinations.\n\n\nExamples\n\nfrom colorspace import max_chroma\n# Max Chroma for Hue = 0 (red) with Luminance = 50\nmax_chroma(0, 50)\n\narray([137.96])\n\n\n\n# Max Chroma for Hue = 0 (red) for different Luminance levels\nmax_chroma(0, [25, 50, 75])\n\narray([ 69.51, 137.96,  64.37])\n\n\n\n# Max Chroma for Hue in sequence [0, 360] by 60, Luminace = 50\nimport numpy as np\nmax_chroma(np.arange(0, 360, 60), 50)\n\narray([137.96,  59.99,  69.06,  39.81,  65.45, 119.54])\n\n\n\n# Same as above but floored\nmax_chroma(np.arange(0, 360, 60), 50, floor = True)\n\narray([137.,  59.,  69.,  39.,  65., 119.])\n\n\n\n\nRaises\n\n\nTypeError: If unexpected input on H or L.\n\nTypeError: If length of H and L do not match (see description).\n\nTypeError: If input floor is not bool.",
    "crumbs": [
      "Home",
      "Function references",
      "max_chroma"
    ]
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Release Notes",
    "section": "",
    "text": "The software is published under the Gnu Public License on GitHub Please feel free to use, share, improve, and redistribute the software as long as the attribution is given correctly.\nPlease also feel free to help improving the software (via pull requests, or simply get in touch with me, helping hands would be very welcome)!"
  },
  {
    "objectID": "changelog.html#availability",
    "href": "changelog.html#availability",
    "title": "Release Notes",
    "section": "",
    "text": "The software is published under the Gnu Public License on GitHub Please feel free to use, share, improve, and redistribute the software as long as the attribution is given correctly.\nPlease also feel free to help improving the software (via pull requests, or simply get in touch with me, helping hands would be very welcome)!"
  },
  {
    "objectID": "changelog.html#version-0.4-spring-2024",
    "href": "changelog.html#version-0.4-spring-2024",
    "title": "Release Notes",
    "section": "Version 0.4 (Spring 2024)",
    "text": "Version 0.4 (Spring 2024)\n\nOnce more revamped documentation\nFixed a series of smaller bugs\nAdjusted pytest to current version\nFirst PyPI release on https://pypi.org/project/colorspace/\nRevamped the entire documentation, now Quarto based and still available via https://retostauffer.github.io/python-colorspace/. Creaded with help of the https://retostauffer.github.io/pyp2qmd package."
  },
  {
    "objectID": "changelog.html#version-0.3.0-january-2022",
    "href": "changelog.html#version-0.3.0-january-2022",
    "title": "Release Notes",
    "section": "Version 0.3.0 (January 2022)",
    "text": "Version 0.3.0 (January 2022)\n\nRemoved support for Python 2\nAdding functionality for swatchplots for LinearSegmentedColormap (single object)\nFixed GUI choose_palette()\nAdded mixcolor() for additive color mixing (RGB, CIEXYZ)"
  },
  {
    "objectID": "changelog.html#version-0.1.0-september-17-2018",
    "href": "changelog.html#version-0.1.0-september-17-2018",
    "title": "Release Notes",
    "section": "Version 0.1.0 (September 17, 2018)",
    "text": "Version 0.1.0 (September 17, 2018)\nEarly beta release.\nA wide range of methods are already implemented and roughly tested. I’ve decided to launch it as an early beta release to get some feedback from those who use Python more frequently than I do! Feel free to report bugs, ideas, or even contribute.\nI’ll try to update update the documentation as soon as possible and to improve the package itself, if I can find a free time slot."
  },
  {
    "objectID": "changelog.html#version-0.0.1-beginning-of-september-2018",
    "href": "changelog.html#version-0.0.1-beginning-of-september-2018",
    "title": "Release Notes",
    "section": "Version 0.0.1 (beginning of September 2018)",
    "text": "Version 0.0.1 (beginning of September 2018)\nDevelopment version.\nFirst implementation of the colorspace package in Python. This is still an early alpha version, I am currently working on better documentation, testing, and getting the necessary classes and objects into the package to provide a useful toolbox for Python enthusiasts."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Package Installation",
    "section": "",
    "text": "This package is available via the Python Package index (PyPI) or via GitHub. A few requirements are needed to be able to use the package and all its features.\n\nPython 3.10+\nnumpy\nmatplotlib\nimageio (optional).\n\nPlease use the the GitHub issues to report bugs and issues as well as feature requests. There is no guarantee that feature requests can be accommodated, especially as we try to keep both, the R and Python version of the package, around the same level.\nInstalling\nThe latest release can be directly installed from PyPI using:\npip install colorspace\n… or installing the last version (GitHub head branch) using:\npip install git+https://github.com/retostauffer/python-colorspace\nAlternatively, clone the git repository and install the package from there:\ngit clone https://github.com/retostauffer/python-colorspace.git\ncd python-colorspace && python setup.py install\nUsing a virtual environment\nThe repository contains a Makefile and requirements files to set up virtual environments. Note that this requires make and virtualenv to be installed.\nTo set up a virtual environments the git repository must be cloned first; afterwards you should be able to set up the virtual environment and install the colorspace package.\ngit clone https://github.com/retostauffer/python-colorspace.git\ncd python-colorspace\nmake venv\nmake install\nThis will set up a virtual environment and also install the required Python packages before installing the latest version of the colorspace package from the repository."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "",
    "text": "colorspace is a Python package to create and handle colors and color palettes in Python. Based on the Hue-Chroma-Luminance (HCL) color space effective color palettes can be designed and implemented in your own daily workflow.\nThis package is based on the R colorspace package to make the tools easily available for Python enthusiasts. More information and an interactive interface can also be found on HCLwizard.org.\nThe package itself can be found on GitHub and this documentation is also available on GitHub Pages."
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "Contents",
    "text": "Contents\n\nColor spaces\nHCL-Based Color Palettes\nClasses and Methods\nPalette Visualization and Assessment\nApp for Choosing Palettes Interactively\nColor Vision Deficiency Emulation\nColor Manipulation and Utilities\nApproximate Colors from Other Packages\nSomewhere over the Rainbow"
  },
  {
    "objectID": "index.html#other-packages-and-further-reading",
    "href": "index.html#other-packages-and-further-reading",
    "title": "A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "Other Packages and Further Reading",
    "text": "Other Packages and Further Reading\nMore information and further reading:\n\nHCLwizard.org: More information about the HCL color space, introduction to the colorspace packages (available for R and Python), and some interactive tools to define effective HCL-based color palettes, pick colors, and check existing plots and figures for possible problems in terms of color vision deficiencies.\nA list of scientific articles which provide more detailed insights, e.g.,\nThe end of the rainbow: An open letter to the climate science community by Ed Hawkins, Doug McNeall, David Stephenson, Jonny Williams & Dave Carlson.\nBetter Figures: Constructive criticism of the graphics of climate science by Doug McNeall.\n\nScientific articles with more detailed insights:\n\nZeileis, A., Fisher, J., Hornik, K., Ihaka, R., McWhite, C., Murrell, P., Stauffer, R., & Wilke, C. (2020). colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes. Journal of Statistical Software, 96(1), 1–49, doi: doi:10.18637/jss.v096.i01\nStauffer, R., Mayr, G. J., Dabernig, M., & Zeileis, A. (2015). Somewhere Over the Rainbow: How to Make Effective Use o f Colors in Meteorological Visualizations. American Meteorological Society, 96(2), 203–216, doi:10.1175/BAMS-D-13-00155.1.\nZeileis, A., Hornik, K., & Murrell, P. (2009). Escaping RGBland: Selecting colors for statistical graphics. Computational Statistics & Data Analysis, 53(9), 3259–3270, doi:10.1016/j.csda.2008.11.033.\nIhaka, R., 2003. [Colour for presentation graphics](http://www.ci.tuwien.ac.at/Conferences/DSC-2003/Proceedings/Ihaka.pdf. In: Hornik, K., Leisch, F., Zeileis, A. (Eds.), Proceedings of the 3rd International Workshop on Distributed Statistical Computing, Vienna, Austria, ISSN 1609-395X, URL: http://www.ci.tuwien.ac.at/Conferences/DSC-2003/Proceedings/Ihaka.pdf.\nAnd others (HCLwizard.org reference list).\n\nSome other packages providing color maps in Python (on top of the default color maps) wich might be of interest:\n\nseaborn: Statistical data visualization. The package also provides access to a range of (mostly) well specified color palettes.\npalettable: Color palettes for Python. Formely known as brewer2mpl. Provides a range of color palettes including “Brewer2” and “Carto” palettes.\nColorBrewer2.org: The source of the brewer colors, interactive web page by Cynthia Brewer, Mark Harrower, and The Pennsylvania State University."
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.set_whitepoint.html",
    "href": "man/colorspace.colorlib.CIEXYZ.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nCIEXYZ.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.show_settings.html",
    "href": "man/colorspace.palettes.diverging_hsv.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\ndiverging_hsv.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.cmap.html",
    "href": "man/colorspace.palettes.sequential_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\nsequential_hcl.cmap(n=101,                    name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.swatchplot.html",
    "href": "man/colorspace.colorlib.CIELAB.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nCIELAB.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.qualitative_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nqualitative_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.get.html",
    "href": "man/colorspace.colorlib.RGB.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nRGB.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.cvd_emulator.cvd_emulator.html",
    "href": "man/colorspace.cvd_emulator.cvd_emulator.html",
    "title": "Check Images for Color Constraints",
    "section": "",
    "text": "Description\nSimulate color deficiencies on png, jpg, and jpeg files. Takes an existing pixel image and simulates different color vision deficiencies.\nThe function displays a matplotlib figure if output = None. If output is set, a new figure will be stored with simulated colors. If only one color vision deficiency is defined (e.g., cvd = \"desaturate\") a figure of the same type and size as the input figure is created. When multiple cvd’s are specified, a multi-panel plot will be created.\nRequires the python modules matplotlib and imageio to be installed.\n\n\nUsage\ncvd_emulator(image='DEMO',             cvd='desaturate',             severity=1.0, output=None,             dropalpha=False)\n\n\nArguments\n\n\nimagestr\n\n\nName of the figure which should be converted (png/jpg/jpeg). If image = \"DEMO\" the package demo figure is used.\n\n\ncvdstr, list\n\n\nColor vision deficiency or deficiencies. Allowed types are \"deutanope\", \"protanope\", \"tritanope\", \"desaturated\", and \"original\" (unmodified).\n\n\nseverityfloat\n\n\nHow severe the color vision deficiency is ([0.,1.]). Also used as the amount of desaturation if cvd includes \"desaturate\".\n\n\noutputNone, str\n\n\nIf None an interactive plotting window will be opened. A str (file name/path) can be given to write the result to disc.\n\n\ndropalphabool\n\n\nDrop alpha channel, defaults to False. Only useful for png figures having an alpha channel.\n\n\n\n\nReturn\nmatplotlib.figure.Figure, str: If output = None the figure handler is returned, else the return of the function is identical to output; the figure which has just been created.\n\n\nExamples\n\nfrom colorspace import cvd_emulator\ncvd_emulator(\"DEMO\", \"deutan\", 0.5);\n\n\n\n\n\n\n\n\n\ncvd_emulator(\"DEMO\", \"desaturate\", 1.0, \"output.png\");\n\n\n\n\n\n\n\n\n\ncvd_emulator(\"DEMO\", [\"original\", \"deutan\", \"protan\"],\n             0.5, dropalpha = True);\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nValueError: If cvd is empty.\n\nValueError: If no valid cvd method is provided.\n\nFileNotFounderror: If the file specified on image does not exist.\n\nImportError: When python module 'imageio' cannot be imported (not installed).\n\nIOError: If file image cannot be read using imageio.imread.\n\nImportError: If matplotlib.pyplot cannot be imported (matplotlib not installed?).",
    "crumbs": [
      "Home",
      "Function references",
      "cvd_emulator"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.to.html",
    "href": "man/colorspace.colorlib.HLS.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nHLS.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.get_whitepoint.html",
    "href": "man/colorspace.colorlib.CIELUV.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nCIELUV.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.sequential_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nsequential_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.utils.mixcolor.html",
    "href": "man/colorspace.utils.mixcolor.html",
    "title": "Compute the Convex Combination of Two Colors",
    "section": "",
    "text": "Description\nThis function can be used to compute the result of color mixing, assuming additive mixing (e.g., as appropriate for RGB and XYZ).\n\n\nUsage\nmixcolor(alpha, color1, color2, where=1)\n\n\nArguments\n\n\nalphafloat\n\n\nThe mixed color is obtained by combining an amount 1 - alpha of color1 with an amount alpha of color2.\n\n\ncolor1\n\n\nan object that can be converted into a palette.\n\n\ncolor2\n\n\na second object that can be converted into a palette. Must have the same number of colors as the argument on color1.\n\n\nwherestr\n\n\nThe color space where the mixing is to take place, either \"RGB\" or \"CIEXYZ\".\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import RGB\nfrom colorspace.colorlib import hexcols\nfrom colorspace import *\n# Mixing two colors defined in the RGB space\n# via colorspace.colorlib.RGB. Mixing half-half\n# in the RGB color space (M1) and in the HCL space (M2).\nRGB_1  = RGB(R = 1, G = 0, B = 0)\nRGB_2  = RGB(R = 0, G = 1, B = 0)\nRGB_M1 = mixcolor(0.5, RGB_1, RGB_2, \"RGB\")\nRGB_M1\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[1], line 9\n      7 RGB_1  = RGB(R = 1, G = 0, B = 0)\n      8 RGB_2  = RGB(R = 0, G = 1, B = 0)\n----&gt; 9 RGB_M1 = mixcolor(0.5, RGB_1, RGB_2, \"RGB\")\n     10 RGB_M1\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/utils.py:92, in mixcolor(alpha, color1, color2, where)\n     90 allowed_spaces = [\"sRGB\", \"CIEXYZ\"]\n     91 if not where in allowed_spaces:\n---&gt; 92     raise ValueError(f\"argument `{where}` none of the allowed types: {', '.join(allowed_spaces)}\")\n     94 # Converting colors\n     95 try:\n\nValueError: argument `RGB` none of the allowed types: sRGB, CIEXYZ\n\n\n\n\n# Mixing via XYZ color space\nRGB_M2 = mixcolor(0.5, RGB_1, RGB_2, \"CIEXYZ\")\nRGB_M2\n\nCIEXYZ color object (1 colors)\n           X       Y       Z\n  1:   38.50   46.39    6.93\n\n\n\n# Mixing two lists of hex-colors of length 5.\n#  Mixing takes place once in the RGB color space (M1)\n#  and once in the HCL color space (M2)\nHEX_1  = diverging_hcl()(5)\nHEX_2  = diverging_hcl(rev = True)(5)\nHEX_M1 = mixcolor(0.2, HEX_1, HEX_2, \"sRGB\")\nHEX_M1\n\nsRGB color object (5 colors)\n           R       G       B\n  1:    0.12    0.20    0.56\n        0.66    0.64    0.76\n        0.89    0.89    0.89\n        0.76    0.62    0.67\n        0.45    0.07    0.31\n\n\n\n# Mixing via XYZ color space\nHEX_M2 = mixcolor(0.8, HEX_1, HEX_2, \"CIEXYZ\")\nHEX_M2\n\nCIEXYZ color object (5 colors)\n           X       Y       Z\n  1:   11.33    6.22   11.03\n       42.11   39.02   44.33\n       72.28   76.05   82.80\n       39.59   39.02   56.17\n        9.28    6.27   30.02\n\n\n\nswatchplot([HEX_1, HEX_2, HEX_M1, HEX_M2],\n           show_names = False, figsize = (5.5, 1));\n\n\n\n\n\n\n\n\n\n# Mixing objects of different length and type\n#  Coordinates of the shorter object (RGB_1) will be recycled\n#  to the same number of colors as in the longer object (HEX_2)\nRES_1 = mixcolor(0.2, RGB_1, HEX_2, \"sRGB\")\nRES_1.colors()\n\n['#E8010C', '#F41F21', '#F92D2D', '#EC2128', '#CC0D21']\n\n\n\nRES_2 = mixcolor(0.8, RGB_1, HEX_2, \"sRGB\")\nRES_2.colors()\n\n['#A5052F', '#D57D83', '#E8B5B5', '#B485A0', '#353284']\n\n\n\nswatchplot([RGB_1, RES_2, HEX_2, RES_1, RES_2],\n           show_names = False, figsize = (5.5, 2));\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: In case alpha is not float or int.\n\nValueError: If alpha is not larger than 0.0 and smaller than 1.0.\n\nTypeError: If where is not a str.\n\nValueError: If where is not among the allowed color spaces used for adaptive mixing.\n\nException: If color1 or color2 cannot be converted into a palette object.",
    "crumbs": [
      "Home",
      "Function references",
      "mixcolor"
    ]
  },
  {
    "objectID": "man/colorspace.CVD.protan.html",
    "href": "man/colorspace.CVD.protan.html",
    "title": "Simulate Color Vision Deficiency",
    "section": "",
    "text": "Description\nTransformation of colors by simulating color vision deficiencies, based on a CVD transform matrix. This function is an interface to the CVD object and returns simulated colors for protanope vision.\nSee also deutan, tritan, desaturate, and cvd_emulator.\n\n\nUsage\nprotan(cols, severity=1.0, linear=True)\n\n\nArguments\n\n\ncolslist, colorobject, matplotlib.colors.LinearSegmentedColormap\n\n\nA list of valid hex colors (str) or a colorobject (such as RGB, HCL, CIEXYZ).\n\n\nseverityfloat\n\n\nSeverity in [0., 1.]. Zero means no deficiency, one maximum deficiency, defaults to 1..\n\n\nlinearbool\n\n\nShould the color vision deficiency transformation be applied to the linearised RGB coordinates (default)? If False, the transformation is applied to the gamma-corrected sRGB coordinates (as in the Machado et al. 2009 supplementary materials).\n\n\n\n\nReturn\nReturns an object of the same type as the input object cols with modified colors as people with protanope color vision might see the colors (simulated).\n\n\nExamples\n\nfrom colorspace import rainbow_hcl, protan, palette\nfrom colorspace import specplot, swatchplot\n# Drawing 100 colors along the HCL rainbow color palette\ncols = rainbow_hcl()(100)\nspecplot(cols);\n\n\n\n\n\n\n\n\n\nspecplot(protan(cols));\n\n\n\n\n\n\n\n\n\nspecplot(protan(cols, 0.5));\n\n\n\n\n\n\n\n\n\n# List of (hex) colors\ncols = [\"magenta\", \"red\", \"orange\", \"#F2F204\", \"#6BF204\", \"#4DA00D\"]\nprotan(cols);\n\n\n# Visualize original and simulated color swatches\nswatchplot([cols, protan(cols)],\n           show_names = False, figsize = (5, 1.5));\n\n\n\n\n\n\n\n\n\n# From palette object\npal = palette(cols, name = \"custom palette\")\nprotan(pal)\n\n['#007FFF', '#6D5F00', '#C3AC00', '#FFE700', '#FADC00', '#A69200']\n\n\n\n# From cmap (returns cmap)\nprotan(pal.cmap())\n\ncustom palette  underbad over",
    "crumbs": [
      "Home",
      "Function references",
      "protan"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.specplot.html",
    "href": "man/colorspace.colorlib.HLS.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nHLS.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.get.html",
    "href": "man/colorspace.colorlib.CIELAB.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nCIELAB.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.colors.html",
    "href": "man/colorspace.colorlib.CIELUV.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nCIELUV.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.hasalpha.html",
    "href": "man/colorspace.colorlib.RGB.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nRGB.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.specplot.html",
    "href": "man/colorspace.colorlib.hexcols.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nhexcols.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.name.html",
    "href": "man/colorspace.palettes.rainbow.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\nrainbow.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.set.html",
    "href": "man/colorspace.colorlib.RGB.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nRGB.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.hasalpha.html",
    "href": "man/colorspace.colorlib.HSV.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nHSV.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.dropalpha.html",
    "href": "man/colorspace.colorlib.HLS.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nHLS.dropalpha()"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.RGB_to_XYZ.html",
    "href": "man/colorspace.colorlib.colorlib.RGB_to_XYZ.html",
    "title": "Convert RGB to CIEXYZ",
    "section": "",
    "text": "Description\nR, G, and B give the levels of red, green and blue as values in the interval [0., 1.]. XN, YN, and ZN allow to specify additional CIE chromaticities to specify a specific white point.\n\n\nUsage\ncolorlib.RGB_to_XYZ(R, G, B, XN=None, YN=None,                    ZN=None)\n\n\nArguments\n\n\nRnumpy.ndarray\n\n\nIntensities for red ([0., 1.]).\n\n\nGnumpy.ndarray\n\n\nIntensities for green ([0., 1.]).\n\n\nBnumpy.ndarray\n\n\nIntensities for blue ([0., 1.]).\n\n\nXNNone, numpy.ndarray\n\n\nChromaticity of the white point. If of length 1, the white point specification will be recycled if needed. When not specified (all None) a default white point is used.\n\n\nYN\n\n\nSee XN.\n\n\nZN\n\n\nSee XN.\n\n\n\n\nReturn\nReturns corresponding coordinates of CIE chromaticities, a list of numpy.ndarrays of the same length as the inputs ([X, Y, Z])."
  },
  {
    "objectID": "man/colorspace.utils.darken.html",
    "href": "man/colorspace.utils.darken.html",
    "title": "Algorithmically Darken Colors",
    "section": "",
    "text": "Description\nTakes one or multiple colors and adjust them sucht hat they apper darkened. See also: lighten.\n\n\nUsage\ndarken(col, amount=0.1, method='relative',       space='HCL', fixup=True)\n\n\nArguments\n\n\ncol\n\n\ncolor (or colors) to be manipulated. Can be a color object, a palette object, or a str/list of str with valid hex colors.\n\n\namountfloat\n\n\nvalue between [0., 1.] with the amount the colors should be lightened. Defaults to 0.1.\n\n\nmethodstr\n\n\neither \"relative\" (default) or \"absolute\".\n\n\nspacestr\n\n\none of \"HCL\" or \"HSV\". Defaults to \"HCL\".\n\n\nfixupbool\n\n\nshould colors which fall outside the defined RGB space be fixed (corrected)? Defaults to True.\n\n\n\n\nExamples\n\nfrom colorspace import darken, lighten, swatchplot\noriginal = \"#ff3322\"\nlighter  = lighten(original, amount = 0.3, method = \"relative\", space = \"HCL\")\ndarker   = darken(original,  amount = 0.3, method = \"relative\", space = \"HCL\")\nswatchplot([lighter, original, darker],\n           show_names = False, figsize = (6, 1));\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If method is not str.\n\nValueError: If method is not one of &quot;absolute&quot; or &quot;relative&quot;.\n\nTypeError: If space is not str.\n\nValueError: If space is not one of &quot;HCL&quot; or &quot;HSV&quot;.\n\nTypeError: If 'col' is not among the one of the recognized objects.\n\nTypeError: If fixup is not bool.",
    "crumbs": [
      "Home",
      "Function references",
      "darken"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.get.html",
    "href": "man/colorspace.palettes.heat_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\nheat_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.get.html",
    "href": "man/colorspace.palettes.diverging_hsv.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\ndiverging_hsv.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.utils.extract_transparency.html",
    "href": "man/colorspace.utils.extract_transparency.html",
    "title": "Extract Alpha Channel",
    "section": "",
    "text": "Description\nCurrently only for colorobjects. This function interfaces the .get() method of the object.\n\n\nUsage\nextract_transparency(x, mode='float')\n\n\nArguments\n\n\nx\n\n\nan object which inherits from colorsspace.colorlib.colorobject or an object of class colorspace.palettes.palette.\n\n\nmodestr\n\n\nmode of the return. One of \"float\", \"int\", or \"str\".\n\n\n\n\nReturn\nNone, numpy.ndarray: None if the colorobject has no alpha channel, else a numpy.ndarray. The dtype of the array depends on the mode specified.\n\n\nExamples\n\nfrom colorspace import *\nfrom colorspace.colorlib import hexcols\n\n# Three colors without alpha\ncols1 = ['#023FA5',   '#E2E2E2',   '#8E063B']\n# Same colors with transparency 80%, 40%, 80%\ncols2 = ['#023FA5CC', '#E2E2E266', '#8E063BCC']\n\n# Convert hex color lists to colorobjects\nx1 = hexcols(cols1)\nx2 = hexcols(cols2)\n# Extract transparency\nextract_transparency(x1)\n\n\nextract_transparency(x2)\n\narray([0.8, 0.4, 0.8])\n\n\n\n# Return mode\nextract_transparency(x2, mode = \"float\")\n\narray([0.8, 0.4, 0.8])\n\n\n\nextract_transparency(x2, mode = \"int\")\n\narray([204, 102, 204], dtype=int16)\n\n\n\nextract_transparency(x2, mode = \"str\")\n\narray(['CC', '66', 'CC'], dtype='&lt;U2')\n\n\n\n# Extracting transparency from palette objects\nfrom colorspace import palette\np1 = palette(cols1, name = \"custom palette 1\")\np2 = palette(cols2, name = \"custom palette 2\")\n\n\n# No return as colors in palette `p1` have no transparency\nextract_transparency(p1, mode = \"str\")\n\n\n# Extracting transparency from colors in palette `p2`\nextract_transparency(p2, mode = \"str\")\n\narray(['CC', '66', 'CC'], dtype='&lt;U2')\n\n\n\n\nRaises\n\n\nTypeError: If input object does not inherit from colorobject.\n\nTypeError: If 'mode' is not str.\n\nValueError: If 'mode' is not one of the allowed types shown in the arguments description.",
    "crumbs": [
      "Home",
      "Function references",
      "extract_transparency"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.hasalpha.html",
    "href": "man/colorspace.colorlib.sRGB.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nsRGB.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.CVD.tritan.html",
    "href": "man/colorspace.CVD.tritan.html",
    "title": "Simulate Color Vision Deficiency",
    "section": "",
    "text": "Description\nTransformation of R colors by simulating color vision deficiencies, based on a CVD transform matrix. This function is an interface to the CVD object and returns simulated colors for tritanope vision.\nSee also deutan, protan, desaturate, and cvd_emulator.\n\n\nUsage\ntritan(cols, severity=1.0, linear=True)\n\n\nArguments\n\n\ncolslist, colorobject, matplotlib.colors.LinearSegmentedColormap\n\n\nSingle hex color, list of hex colors (str), a matoplotlib cmap, or a color color object (such as RGB, hexcols, CIELUV).\n\n\nseverityfloat\n\n\nSeverity in [0., 1.]. Zero means no deficiency, one maximum deficiency, defaults to 1..\n\n\nlinearbool\n\n\nShould the color vision deficiency transformation be applied to the linearised RGB coordinates (default)? If False, the transformation is applied to the gamma-corrected sRGB coordinates (as in the Machado et al. 2009 supplementary materials).\n\n\n\n\nReturn\nReturns an object of the same type as the input object cols with modified colors as people with tritanomaly see these colors (simulated).\n\n\nExamples\n\nfrom colorspace import rainbow_hcl, tritan, palette\nfrom colorspace import specplot, swatchplot\n# Drawing 100 colors along the HCL rainbow color palette\ncols = rainbow_hcl()(100)\nspecplot(cols);\n\n\n\n\n\n\n\n\n\nspecplot(tritan(cols));\n\n\n\n\n\n\n\n\n\nspecplot(tritan(cols, 0.5));\n\n\n\n\n\n\n\n\n\n# List of (hex) colors\ncols = [\"magenta\", \"red\", \"orange\", \"#F2F204\", \"#6BF204\", \"#4DA00D\"]\ntritan(cols);\n\n\n# Visualize original and simulated color swatches\nswatchplot([cols, tritan(cols)],\n           show_names = False, figsize = (5, 1.5));\n\n\n\n\n\n\n\n\n\n# From palette object\npal = palette(cols, name = \"custom palette\")\ntritan(pal)\n\n['#FF4A97', '#FF000F', '#FF8E8D', '#FFE2CE', '#60E9CE', '#489A88']\n\n\n\n# From cmap (returns cmap)\ntritan(pal.cmap())\n\ncustom palette  underbad over",
    "crumbs": [
      "Home",
      "Function references",
      "tritan"
    ]
  },
  {
    "objectID": "man/colorspace.hcl_palettes.divergingx_palettes.html",
    "href": "man/colorspace.hcl_palettes.divergingx_palettes.html",
    "title": "Diverging X HCL Palettes",
    "section": "",
    "text": "Description\nReturns pre-defined ‘diverging xtra’ color palettes based on the HCL (Hue-Chroma-Luminance) color model.\n\n\nUsage\ndivergingx_palettes(n=5, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nnumber of colors used when plotting, defaults to 5.\n\n\n**kwargs\n\n\nforwarded to hcl_palettes. For a list and description of available arguments see the description of hcl_palettes.\n\n\n\n\nExamples\n\nfrom colorspace import divergingx_palettes\n# Get palettes\ndivergingx_palettes()\n\nHCL palettes\n\nType:  Advanced: DivergingX\nNames: ArmyRose, Earth, Fall, Geyser, TealRose, Temps, PuOr\n       RdBu, RdGy, PiYG, PRGn, BrBG, RdYlBu, RdYlGn, Spectral\n       Zissou 1, Cividis, Roma\n\n\n\n# Visualize palettes\ndivergingx_palettes(n = 15, ncol = 2, plot = True, figsize = (7, 5));\n\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: divide by zero encountered in divide\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: invalid value encountered in divide\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: invalid value encountered in multiply\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))",
    "crumbs": [
      "Home",
      "Function references",
      "divergingx_palettes"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.to.html",
    "href": "man/colorspace.colorlib.CIELUV.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nCIELUV.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.swatchplot.html",
    "href": "man/colorspace.colorlib.sRGB.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nsRGB.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.get.html",
    "href": "man/colorspace.colorlib.hexcols.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nhexcols.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.specplot.html",
    "href": "man/colorspace.palettes.divergingx_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\ndivergingx_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.set_whitepoint.html",
    "href": "man/colorspace.colorlib.polarLUV.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\npolarLUV.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.hasalpha.html",
    "href": "man/colorspace.colorlib.HLS.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nHLS.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.show_settings.html",
    "href": "man/colorspace.palettes.heat_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\nheat_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.dropalpha.html",
    "href": "man/colorspace.colorlib.polarLUV.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\npolarLUV.dropalpha()"
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.to.html",
    "href": "man/colorspace.colorlib.sRGB.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nsRGB.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.swatchplot.html",
    "href": "man/colorspace.colorlib.RGB.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nRGB.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.colors.html",
    "href": "man/colorspace.colorlib.HLS.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nHLS.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.html",
    "href": "man/colorspace.colorlib.RGB.html",
    "title": "Create RGB Color Object",
    "section": "",
    "text": "Description\nAllows conversions to: CIELAB, CIELUV, CIEXYZ, HLS, HSV, hexcols. polarLAB, polarLUV and sRGB.\n\n\nUsage\nRGB(R, G, B, alpha=None)\n\n\nArguments\n\n\nRint, float, list, numpy.array\n\n\nNumeric value(s) for red intensity ([0., 1.]).\n\n\nGint, float, list, numpy.array\n\n\nNumeric value(s) for green intensity ([0., 1.]).\n\n\nBint, float, list, numpy.array\n\n\nNumeric value(s) for blue intensity ([0., 1.]).\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\nRGB.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nRGB.dropalpha()\n\n\nRemove Alpha Channel\n\n\nRGB.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nRGB.get_whitepoint()\n\n\nGet White Point\n\n\nRGB.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nRGB.length()\n\n\nGet Number of Colors\n\n\nRGB.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nRGB.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nRGB.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nRGB.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nRGB.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import RGB\n# Constructing color object with one single color via float\nRGB(1., 0.3, 0.5)\n\nRGB color object (1 colors)\n           R       G       B\n  1:    1.00    0.30    0.50\n\n\n\n# Constructing object via lists\nRGB([1., 0.8], [0.5, 0.5], [0.0, 0.2])\n\nRGB color object (2 colors)\n           R       G       B\n  1:    1.00    0.50    0.00\n        0.80    0.50    0.20\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\nRGB(asarray([1., 0.8]), asarray([0.5, 0.5]), asarray([0.0, 0.2]))\n\nRGB color object (2 colors)\n           R       G       B\n  1:    1.00    0.50    0.00\n        0.80    0.50    0.20",
    "crumbs": [
      "Home",
      "Class references",
      "RGB"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.get.html",
    "href": "man/colorspace.palettes.terrain_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\nterrain_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.get_whitepoint.html",
    "href": "man/colorspace.colorlib.HSV.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nHSV.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.HLS_to_sRGB.html",
    "href": "man/colorspace.colorlib.colorlib.HLS_to_sRGB.html",
    "title": "Convert HLC to Standard RGB (sRGB)",
    "section": "",
    "text": "Description\nAll r/g/b values in [0., 1.], h in [0., 360.], l and s in [0., 1.].\n\n\nUsage\ncolorlib.HLS_to_sRGB(h, l, s)\n\n\nArguments\n\n\nhnumpy.ndarray\n\n\nHue values.\n\n\nlnumpy.ndarray\n\n\nLightness.\n\n\nsnumpy.ndarray\n\n\nSaturation.\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays with the corresponding coordinates in the sRGB color space ([r, g, b]). Same length as the inputs."
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.specplot.html",
    "href": "man/colorspace.colorlib.sRGB.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nsRGB.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.specplot.html",
    "href": "man/colorspace.palettes.terrain_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nterrain_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.cmap.html",
    "href": "man/colorspace.palettes.terrain_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\nterrain_hcl.cmap(n=101,                 name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.html",
    "href": "man/colorspace.colorlib.CIELAB.html",
    "title": "Create CIELAB Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the CIELAB color space. Can be converted to: CIEXYZ, CIELUV, CIELAB, RGB, sRGB, polarLAB, and hexcols. Not allowed (ambiguous) are transformations to HSV and HLS.\n\n\nUsage\nCIELAB(L, A, B, alpha=None)\n\n\nArguments\n\n\nLint, float, list, numpy.array\n\n\nNumeric value(s) for L dimension.\n\n\nAint, float, list, numpy.array\n\n\nNumeric value(s) for A dimension.\n\n\nBint, float, list, numpy.array\n\n\nNumeric value(s) for B dimension.\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\nCIELAB.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nCIELAB.dropalpha()\n\n\nRemove Alpha Channel\n\n\nCIELAB.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nCIELAB.get_whitepoint()\n\n\nGet White Point\n\n\nCIELAB.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nCIELAB.length()\n\n\nGet Number of Colors\n\n\nCIELAB.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nCIELAB.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nCIELAB.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nCIELAB.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nCIELAB.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import CIELAB\n# Constructing color object with one single color via float\nCIELAB(-30, 10, 10)\n\nCIELAB color object (1 colors)\n           L       A       B\n  1:  -30.00   10.00   10.00\n\n\n\n# Constructing object via lists\nCIELAB([-30, 30], [20, 80], [40, 40])\n\nCIELAB color object (2 colors)\n           L       A       B\n  1:  -30.00   20.00   40.00\n       30.00   80.00   40.00\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\nCIELAB(asarray([-30, 30]), asarray([20, 80]), asarray([40, 40]))\n\nCIELAB color object (2 colors)\n           L       A       B\n  1:  -30.00   20.00   40.00\n       30.00   80.00   40.00",
    "crumbs": [
      "Home",
      "Class references",
      "CIELAB"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.cmap.html",
    "href": "man/colorspace.palettes.divergingx_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\ndivergingx_hcl.cmap(n=101,                    name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.to.html",
    "href": "man/colorspace.colorlib.hexcols.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nhexcols.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.set.html",
    "href": "man/colorspace.colorlib.sRGB.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nsRGB.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.set.html",
    "href": "man/colorspace.colorlib.CIELAB.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nCIELAB.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.RGB_to_sRGB.html",
    "href": "man/colorspace.colorlib.colorlib.RGB_to_sRGB.html",
    "title": "Convert RGB to Standard RGB",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.RGB_to_sRGB(R, G, B, gamma=2.4)\n\n\nArguments\n\n\nRnumpy.ndarray\n\n\nIntensities for red ([0., 1.]).\n\n\nGnumpy.ndarray\n\n\nIntensities for green ([0., 1.]).\n\n\nBnumpy.ndarray\n\n\nIntensities for blue ([0., 1.]).\n\n\ngammafloat\n\n\ngamma adjustment, defaults to 2.4.\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays with R, G, and B values."
  },
  {
    "objectID": "man/colorspace.palettes.palette.swatchplot.html",
    "href": "man/colorspace.palettes.palette.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\npalette.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nforwarded to swatchplot. Note that show_names will always be set to False.\n\n\n\n\nExamples\n\nfrom colorspace import palette\npal = palette([\"#FCFFC9\", \"#E8C167\", \"#D67500\", \"#913640\", \"#1D0B14\"],\n              name = \"Custom Palette\")\npal.swatchplot()\npal.swatchplot(figsize = (5, 1))"
  },
  {
    "objectID": "man/colorspace.choose_palette.choose_palette.html",
    "href": "man/colorspace.choose_palette.choose_palette.html",
    "title": "Graphical user interface to choose HCL based color palettes",
    "section": "",
    "text": "Description\nOpens a tcltk based graphical user interface (GUI) which allows to tweak existing Hue-Chroma-Luminance (HCL) based color palettes and define custom palettes.\n\n\nUsage\nchoose_palette(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nOptional, can be used to change the defaults when starting the GUI. Currently a parameter called palette is allowed to specify the initial color palette. If not set, palette=\"Blue-Red\" is used.\n\n\n\n\nReturn\nAn HCL palette object which allows to extract the colors in different ways. The default is to retrieve hex colors. More details on: diverging_hcl, qualitative_hcl, or sequential_hcl.",
    "crumbs": [
      "Home",
      "Function references",
      "choose_palette"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.html",
    "href": "man/colorspace.colorlib.hexcols.html",
    "title": "Create Hex Color Object",
    "section": "",
    "text": "Description\nCreates a color object using hex colors (str). Can be converted to all other color spaces: CIELAB, CIELUV, CIEXYZ, HLS, HSV, RGB, polarLAB, polarLUV, and sRGB.\n\n\nUsage\nhexcols(hex_)\n\n\nArguments\n\n\nhex_str, list of str, numpy.ndarray of type str\n\n\nHex colors. Only six and eight digit hex colors are allowed (e.g., #000000 or #00000050 if with alpha channel). If invalid hex colors are provided the object will raise an exception. Invalid hex colors will be handled as numpy.nan.\n\n\n\n\nMethods\n\n\nhexcols.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nhexcols.dropalpha()\n\n\nRemove Alpha Channel\n\n\nhexcols.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nhexcols.get_whitepoint()\n\n\nGet White Point\n\n\nhexcols.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nhexcols.length()\n\n\nGet Number of Colors\n\n\nhexcols.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nhexcols.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nhexcols.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nhexcols.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nhexcols.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\n# Creating hex color object from string\nhexcols(\"#cecece\")\n\nhexcols color object (1 colors)\n        hex_\n  1:b'#cecece'\n\n\n\n# Creating hex color object from list of strings\nhexcols([\"#ff0000\", \"#00ff00\"])\n\nhexcols color object (2 colors)\n        hex_\n  1:b'#ff0000'\n    b'#00ff00'\n\n\n\n# Creating hex colors via numpy array\nfrom numpy import asarray\ncols = hexcols(asarray([\"#ff000030\", \"#00ff0030\"]))\ncols\n\nhexcols color object (2 colors)\n        hex_   alpha\n  1:b'#ff0000'    30\n    b'#00ff00'    30\n\n\n\n# Convert hex colors to another color space (CIEXYZ)\ncols.to(\"CIEXYZ\")\ncols\n\nCIEXYZ color object (2 colors)\n           X       Y       Z   alpha\n  1:   41.25   21.27    1.93    0.19\n       35.76   71.52   11.92    0.19",
    "crumbs": [
      "Home",
      "Class references",
      "hexcols"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.set.html",
    "href": "man/colorspace.colorlib.polarLUV.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\npolarLUV.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.palettes.hclpalettes.get_palette_types.html",
    "href": "man/colorspace.palettes.hclpalettes.get_palette_types.html",
    "title": "Get Palette Types",
    "section": "",
    "text": "Description\nGet all palette types.\n\n\nUsage\nhclpalettes.get_palette_types()\n\n\nReturn\nReturns a list of str with the names of all palette types or groups."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.html",
    "href": "man/colorspace.colorlib.colorlib.html",
    "title": "Color Handling Superclass",
    "section": "",
    "text": "Description\nThe colorlib class provides a series of methods methods which allow to convert colors between different color spaces and is not intended to be used by end-users (not exported).\nUsers should use the dedicated classes for the available color spaces which all extend this class. These are CIELAB, CIELUV, CIEXYZ, HLS, HSV, RGB, hexcols, polarLAB, polarLUV, and sRGB.\n\n\nUsage\ncolorlib()\n\n\nMethods\n\n\ncolorlib.DEG2RAD(x)\n\n\nConvert degrees into radiant\n\n\ncolorlib.HLS_to_sRGB(h, l, s)\n\n\nConvert HLC to Standard RGB (sRGB)\n\n\ncolorlib.HSV_to_sRGB(h, s, v)\n\n\nConvert HSV to Standard RGB (sRGB)\n\n\ncolorlib.LAB_to_XYZ(L, A, B, XN=None, YN=None, ZN=None)\n\n\nConvert CIELAB to CIEXYZ\n\n\ncolorlib.LAB_to_polarLAB(L, A, B)\n\n\nConvert CIELAB to the polar representation (polarLAB)\n\n\ncolorlib.LUV_to_XYZ(L, U, V, XN=None, YN=None, ZN=None)\n\n\nConvert CIELUV to CIELAB.\n\n\ncolorlib.LUV_to_polarLUV(L, U, V)\n\n\nConvert CIELUV to the polar representation (polarLUV; HCL)\n\n\ncolorlib.RAD2DEG(x)\n\n\nConvert radiant to degrees\n\n\ncolorlib.RGB_to_XYZ(R, G, B, XN=None, YN=None, ZN=None)\n\n\nConvert RGB to CIEXYZ\n\n\ncolorlib.RGB_to_sRGB(R, G, B, gamma=2.4)\n\n\nConvert RGB to Standard RGB\n\n\ncolorlib.XYZ_to_LAB(X, Y, Z, XN=None, YN=None, ZN=None)\n\n\nConvert CIEXYZ to CIELAB\n\n\ncolorlib.XYZ_to_LUV(X, Y, Z, XN=None, YN=None, ZN=None)\n\n\nConvert CIEXYZ to CIELUV.\n\n\ncolorlib.XYZ_to_RGB(X, Y, Z, XN=None, YN=None, ZN=None)\n\n\nConvert CIEXYZ to RGB\n\n\ncolorlib.XYZ_to_uv(X, Y, Z)\n\n\nConvert CIEXYZ to u and v\n\n\ncolorlib.ftrans(u, gamma)\n\n\nGamma Correction\n\n\ncolorlib.gtrans(u, gamma)\n\n\nGamma Correction\n\n\ncolorlib.hex_to_sRGB(hex_, gamma=2.4)\n\n\nConvert Hex Colors to Standard RGB (sRGB)\n\n\ncolorlib.polarLAB_to_LAB(L, C, H)\n\n\nConvert polarLAB to CIELAB\n\n\ncolorlib.polarLUV_to_LUV(L, C, H)\n\n\nConvert Polar CIELUV (HCL) to CIELUV\n\n\ncolorlib.sRGB_to_HLS(r, g, b)\n\n\nConvert Standard RGB (sRGB) to HLS\n\n\ncolorlib.sRGB_to_HSV(r, g, b)\n\n\nConvert RGB to HSV\n\n\ncolorlib.sRGB_to_RGB(R, G, B, gamma=2.4)\n\n\nConvert Standard RGB to RGB\n\n\ncolorlib.sRGB_to_hex(r, g, b, fixup=True)\n\n\nConvert Standard RGB (sRGB) to Hex Colors",
    "crumbs": [
      "Home",
      "Class references",
      "colorlib"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.hclpalettes.length.html",
    "href": "man/colorspace.palettes.hclpalettes.length.html",
    "title": "Get Number of Palettes",
    "section": "",
    "text": "Description\nGet length of palette.\n\n\nUsage\nhclpalettes.length()\n\n\nReturn\nInteger, number of palettes in the object."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.dropalpha.html",
    "href": "man/colorspace.colorlib.polarLAB.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\npolarLAB.dropalpha()"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow.colors.html",
    "href": "man/colorspace.palettes.rainbow.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\nrainbow.colors(n=11, alpha=None, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned. Defaults to 11.\n\n\nalphaNone, float\n\n\nFloat (single value) or vector of floats in the range of [0.,1.] for alpha transparency channel (0. means full transparency, 1. opaque). If a single value is provided it will be applied to all colors, if a vector is given the length has to be n.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return.\n\n\n\n\nRaises\n\n\nValueError: If input n is not float/int or smaller than 1."
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.colors.html",
    "href": "man/colorspace.palettes.qualitative_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\nqualitative_hcl.colors(n=11, fixup=None, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned, defaults to 11.\n\n\nfixupNone, bool\n\n\nshould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\n**kwargs\n\n\nIf any colorobject = argument is specified, HCL colors will be returned."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.ftrans.html",
    "href": "man/colorspace.colorlib.colorlib.ftrans.html",
    "title": "Gamma Correction",
    "section": "",
    "text": "Description\nFunction gtrans and ftrans provide gamma correction which can be used to switch between sRGB and linearised sRGB (RGB).\nThe standard value of gamma for sRGB displays is approximately 2.2, but more accurately is a combination of a linear transform and a power transform with exponent 2.4. gtrans maps linearised sRGB to sRGB, ftrans provides the inverse mapping.\n\n\nUsage\ncolorlib.ftrans(u, gamma)\n\n\nArguments\n\n\nunumpy.ndarray\n\n\nFloat array of length N.\n\n\ngammafloat, numpy.ndarray\n\n\ngamma value; if float or numpy.ndarray of length one, gamma will be recycled if needed.\n\n\n\n\nReturn\nGamma corrected values, same length as input u."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.sRGB_to_RGB.html",
    "href": "man/colorspace.colorlib.colorlib.sRGB_to_RGB.html",
    "title": "Convert Standard RGB to RGB",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.sRGB_to_RGB(R, G, B, gamma=2.4)\n\n\nArguments\n\n\nRnumpy.ndarray\n\n\nIntensities for red ([0., 1.]).\n\n\nGnumpy.ndarray\n\n\nIntensities for green ([0., 1.]).\n\n\nBnumpy.ndarray\n\n\nIntensities for blue ([0., 1.]).\n\n\ngammafloat\n\n\ngamma adjustment, defaults to 2.4.\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays with R, G, and B values."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.set_whitepoint.html",
    "href": "man/colorspace.colorlib.CIELAB.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nCIELAB.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.specplot.html",
    "href": "man/colorspace.colorlib.RGB.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nVisualization of the spectrum of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nRGB.specplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to specplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.specplot();\ncols.specplot(rgb = False, figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.html",
    "href": "man/colorspace.palettes.diverging_hsv.html",
    "title": "Diverging HSV Color Palettes",
    "section": "",
    "text": "Description\nSee also: qualitative_hcl, sequential_hcl, diverging_hcl, divergingx_hcl, rainbow_hcl, heat_hcl, terrain_hcl, and rainbow.\n\n\nUsage\ndiverging_hsv(h=[240, 0], s=1.0, v=1.0, power=1.0,              fixup=True, rev=False, *args,              **kwargs)\n\n\nArguments\n\n\nhlist of numerics\n\n\nHue values, diverging color palettes should have different hues for both ends of the palette. If only one value is present it will be recycled ending up in a diverging color palette with the same colors on both ends. If more than two values are provided the first two will be used while the rest is ignored. If input h is a str this argument acts like the palette argument (see palette input parameter).\n\n\nsfloat\n\n\nSaturation value for the two ends of the palette.\n\n\nvfloat\n\n\nValue (the HSV value) of the two ends of the palette.\n\n\npowernumeric\n\n\nPower parameter for non-linear behaviour of the color palette.\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nUnused.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\ndiverging_hsv.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\ndiverging_hsv.colors(n=11, fixup=True, **kwargs)\n\n\nGet Colors\n\n\ndiverging_hsv.get(key)\n\n\nGet Specific Palette Setting\n\n\ndiverging_hsv.name()\n\n\nGet Palette Name\n\n\ndiverging_hsv.show_settings()\n\n\nShow Palette Settings\n\n\ndiverging_hsv.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\ndiverging_hsv.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hsv\npal = diverging_hsv()\npal.colors(10)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:2313, in diverging_hsv.__init__(self, h, s, v, power, fixup, rev, *args, **kwargs)\n   2312 try:\n-&gt; 2313     h     = self._checkinput_(int,   2, True,  False, h = h)\n   2314     s     = self._checkinput_(float, 1, False, False, s = s)\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:933, in hclpalette._checkinput_(self, dtype, length_min, length_max, recycle, nansallowed, **kwargs)\n    932 for key,value in kwargs.items():\n--&gt; 933     kwargs[key] = fun(key, value, dtype, length_min, length_max, recycle, nansallowed)\n    935 # If only one kwarg was given: return values, else return dict.\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:915, in hclpalette._checkinput_.&lt;locals&gt;.fun(key, value, dtype, length_min, length_max, recycle, nansallowed)\n    914 if length_max and len(value) &gt; length_max:\n--&gt; 915     raise ValueError(f\"wrong length of input \\\"{key}\\\", expected max {length_max} elements, \" + \\\n    916                      f\"got {len(value)} when calling {self.__class__.__name__}\")\n    917 # Cropping data if too much elements are given.\n\nValueError: wrong length of input \"h\", expected max True elements, got 2 when calling diverging_hsv\n\nDuring handling of the above exception, another exception occurred:\n\nValueError                                Traceback (most recent call last)\nCell In[1], line 2\n      1 from colorspace import diverging_hsv\n----&gt; 2 pal = diverging_hsv()\n      3 pal.colors(10)\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:2318, in diverging_hsv.__init__(self, h, s, v, power, fixup, rev, *args, **kwargs)\n   2316     power = self._checkinput_(float, 1, True,  False, power = power)\n   2317 except Exception as e:\n-&gt; 2318     raise ValueError(str(e))\n   2320 # Save settins\n   2321 try:\n\nValueError: wrong length of input \"h\", expected max True elements, got 2 when calling diverging_hsv\n\n\n\n\npal.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 pal.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\nNameError: name 'pal' is not defined\n\n\n\n\n# The standard call of the object also returns hex colors\ndiverging_hsv()(10)\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:2313, in diverging_hsv.__init__(self, h, s, v, power, fixup, rev, *args, **kwargs)\n   2312 try:\n-&gt; 2313     h     = self._checkinput_(int,   2, True,  False, h = h)\n   2314     s     = self._checkinput_(float, 1, False, False, s = s)\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:933, in hclpalette._checkinput_(self, dtype, length_min, length_max, recycle, nansallowed, **kwargs)\n    932 for key,value in kwargs.items():\n--&gt; 933     kwargs[key] = fun(key, value, dtype, length_min, length_max, recycle, nansallowed)\n    935 # If only one kwarg was given: return values, else return dict.\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:915, in hclpalette._checkinput_.&lt;locals&gt;.fun(key, value, dtype, length_min, length_max, recycle, nansallowed)\n    914 if length_max and len(value) &gt; length_max:\n--&gt; 915     raise ValueError(f\"wrong length of input \\\"{key}\\\", expected max {length_max} elements, \" + \\\n    916                      f\"got {len(value)} when calling {self.__class__.__name__}\")\n    917 # Cropping data if too much elements are given.\n\nValueError: wrong length of input \"h\", expected max True elements, got 2 when calling diverging_hsv\n\nDuring handling of the above exception, another exception occurred:\n\nValueError                                Traceback (most recent call last)\nCell In[3], line 2\n      1 # The standard call of the object also returns hex colors\n----&gt; 2 diverging_hsv()(10)\n\nFile /opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:2318, in diverging_hsv.__init__(self, h, s, v, power, fixup, rev, *args, **kwargs)\n   2316     power = self._checkinput_(float, 1, True,  False, power = power)\n   2317 except Exception as e:\n-&gt; 2318     raise ValueError(str(e))\n   2320 # Save settins\n   2321 try:\n\nValueError: wrong length of input \"h\", expected max True elements, got 2 when calling diverging_hsv",
    "crumbs": [
      "Home",
      "Class references",
      "diverging_hsv"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.specplot.html",
    "href": "man/colorspace.palettes.sequential_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nsequential_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.polarLUV_to_LUV.html",
    "href": "man/colorspace.colorlib.colorlib.polarLUV_to_LUV.html",
    "title": "Convert Polar CIELUV (HCL) to CIELUV",
    "section": "",
    "text": "Description\nConvert colors from the polar representation of the CIELUV color space, also known as HCL (Hue-Chroma-Luminance) color space, into CIELAB coordinates. Inverse function of :py:meth:LUV_to_polarLUV.\n\n\nUsage\ncolorlib.polarLUV_to_LUV(L, C, H)\n\n\nArguments\n\n\nWARNING(missing argument definition “C” in docstring)\n\n\nWARNING(missing argument definition “H” in docstring)\n\n\n\n\nLnumpy.ndarray\n\n\nValues for the polar L dimension.\n\n\nUnumpy.ndarray\n\n\nValues for the polar U dimension.\n\n\nVnumpy.ndarray\n\n\nValues for the polar V dimension."
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.diverging_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\ndiverging_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.specplot.html",
    "href": "man/colorspace.palettes.qualitative_hcl.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nqualitative_hcl.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.swatchplot.html",
    "href": "man/colorspace.palettes.diverging_hsv.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\ndiverging_hsv.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.set.html",
    "href": "man/colorspace.colorlib.HSV.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nHSV.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.get.html",
    "href": "man/colorspace.colorlib.polarLUV.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\npolarLUV.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.terrain_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nterrain_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.palettes.terrain_hcl.html",
    "href": "man/colorspace.palettes.terrain_hcl.html",
    "title": "HCL Based Terrain Color Palette",
    "section": "",
    "text": "Description\nTerrain colors, a sequential HCL palette.\nSee also: qualitative_hcl, sequential_hcl, diverging_hcl, divergingx_hcl, rainbow_hcl, heat_hcl, diverging_hsv, and rainbow.\n\n\nUsage\nterrain_hcl(h=[130, 0], c=[80, 0], l=[60, 95],            power=[0.1, 1.0], fixup=True, rev=False,            *args, **kwargs)\n\n\nArguments\n\n\nhlist of int\n\n\nHue parameters (h1/h2).\n\n\nclist of int\n\n\nChroma parameters (c1/c2).\n\n\nlint\n\n\nLuminance parameters (l1/l2).\n\n\npowerlist of float\n\n\nPower parameters (p1/p2).\n\n\ngammafloat\n\n\nGamma value used for transfiromation from/to sRGB. @TODO implemented? Check!\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\nrevbool\n\n\nShould the color map be reversed.\n\n\n*args\n\n\nunused.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings.\n\n\n\n\nReturn\nInitialize new object, no return. Raises a set of errors if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\nterrain_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\nterrain_hcl.colors(n=11, fixup=True, **kwargs)\n\n\nGet Colors\n\n\nterrain_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\nterrain_hcl.name()\n\n\nGet Palette Name\n\n\nterrain_hcl.show_settings()\n\n\nShow Palette Settings\n\n\nterrain_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\nterrain_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import terrain_hcl\npal = terrain_hcl()\npal.colors(10)\n\n['#26A63A',\n '#68AC20',\n '#92B106',\n '#B4B61A',\n '#D3BA3D',\n '#EFBD60',\n '#FFC183',\n '#FFC6A7',\n '#FFCDC9',\n '#F1F1F1']\n\n\n\npal.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\nterrain_hcl()(10)\n\n['#26A63A',\n '#68AC20',\n '#92B106',\n '#B4B61A',\n '#D3BA3D',\n '#EFBD60',\n '#FFC183',\n '#FFC6A7',\n '#FFCDC9',\n '#F1F1F1']",
    "crumbs": [
      "Home",
      "Class references",
      "terrain_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.dropalpha.html",
    "href": "man/colorspace.colorlib.CIEXYZ.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nCIEXYZ.dropalpha()"
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.set_whitepoint.html",
    "href": "man/colorspace.colorlib.sRGB.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nsRGB.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.polarLAB.get_whitepoint.html",
    "href": "man/colorspace.colorlib.polarLAB.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\npolarLAB.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.palettes.heat_hcl.name.html",
    "href": "man/colorspace.palettes.heat_hcl.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "Description\nGet name of color palette.\n\n\nUsage\nheat_hcl.name()\n\n\nReturn\nReturns the name of the palette, str."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.HSV_to_sRGB.html",
    "href": "man/colorspace.colorlib.colorlib.HSV_to_sRGB.html",
    "title": "Convert HSV to Standard RGB (sRGB)",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.HSV_to_sRGB(h, s, v)\n\n\nArguments\n\n\nhnympy.ndarray\n\n\nHue values.\n\n\nsnumpy.ndarray\n\n\nSaturation.\n\n\nvnumpy.ndarray\n\n\nValue (the value-dimension of HSV).\n\n\n\n\nReturn\nReturns a list of numpy.ndarrays with the corresponding coordinates in the sRGB color space ([r, g, b]). Same length as the inputs."
  },
  {
    "objectID": "man/colorspace.palettes.sequential_hcl.show_settings.html",
    "href": "man/colorspace.palettes.sequential_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\nsequential_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.swatchplot.html",
    "href": "man/colorspace.palettes.rainbow_hcl.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nInterfacing the main swatchplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\nrainbow_hcl.swatchplot(n=7, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 7.\n\n\n**kwargs\n\n\nforwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.swatchplot()\npal.swatchplot(n = 21)"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.colors.html",
    "href": "man/colorspace.colorlib.CIELAB.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nCIELAB.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.utils.check_hex_colors.html",
    "href": "man/colorspace.utils.check_hex_colors.html",
    "title": "Checking Hex Color Validity",
    "section": "",
    "text": "Description\nValid hex colors are three digit hex colors (e.g., #F00), six digit hex colors (e.g., #FF00FF), or six digit colors with additional transparency (eight digit representation). If the inputs do not match one of these hex representations matplotlib.color.to_hex will be called. This allows to also convert standard colors such as \"0\", \"black\", or \"magenta\" into their corresponding hex representation.\n\n\nUsage\ncheck_hex_colors(colors)\n\n\nArguments\n\n\ncolorsstr, list, numpy.ndarray\n\n\nstr or list of str with colors. See function description for details. In case it is a numpy.ndarray it will be flattened to 1-dimensional if needed.\n\n\n\n\nReturn\nReturns a list (length 1 or more) in case all values provided are valid hex colors. Three digit colors will be expanded to six digit colors. Else the function will raise a ValueError.\n\n\nExamples\n\nfrom colorspace import check_hex_colors\ncheck_hex_colors(\"#ff003311\")\n\n['#ff003311']\n\n\n\ncheck_hex_colors(\"#ff0033\")\n\n['#ff0033']\n\n\n\ncheck_hex_colors(\"#f03\")\n\n['#ff0033']\n\n\n\ncheck_hex_colors([\"#f0f\", \"#00F\", \"#00FFFF\", \"#ff003311\"])\n\n['#ff00ff', '#0000FF', '#00FFFF', '#ff003311']\n\n\n\ncheck_hex_colors([\"#FFF\", \"0\", \"black\", \"blue\", \"magenta\"])\n\n['#FFFFFF', '#000000', '#000000', '#0000FF', '#FF00FF']\n\n\n\nfrom numpy import asarray\ncheck_hex_colors(asarray([\"#f0f\", \"#00F\", \"#00FFFF\", \"#ff003311\"]))\n\n['#ff00ff', '#0000FF', '#00FFFF', '#ff003311']\n\n\n\n\nRaises\n\n\nValueError: In case colors is a list but does not only contain strnigs.\n\nTypeError: If colors is neither str or list of str.\n\nValueError: If at least one of the colors is an invalid hex color.",
    "crumbs": [
      "Home",
      "Function references",
      "check_hex_colors"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.hclpalettes.plot.html",
    "href": "man/colorspace.palettes.hclpalettes.plot.html",
    "title": "Create swatchplot.",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\nhclpalettes.plot(n=5)\n\n\nArguments\n\n\nnint\n\n\nPositive int, number of colors.\n\n\n\n\nRaises\n\n\nTypeError: If 'n' is not an int.\n\nValueError: If 'n' is not positive."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.hasalpha.html",
    "href": "man/colorspace.colorlib.CIELAB.hasalpha.html",
    "title": "Check for Alpha Channel",
    "section": "",
    "text": "Description\nSmall helper function to check whether the current color object has alpha channel or not.\n\n\nUsage\nCIELAB.hasalpha()\n\n\nReturn\nTrue if alpha values are present, False if not."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.LUV_to_polarLUV.html",
    "href": "man/colorspace.colorlib.colorlib.LUV_to_polarLUV.html",
    "title": "Convert CIELUV to the polar representation (polarLUV; HCL)",
    "section": "",
    "text": "Description\nConverts colors from the CIELUV color space into its polar representation (polarLUV). The polarLUV color space is also known as the HCL (Hue-Chroma-Luminance) color space which this package uses frequently, e.g., when creating efficient color maps. Inverse function of :py:meth:polarLUV_to_LUV.\n\n\nUsage\ncolorlib.LUV_to_polarLUV(L, U, V)\n\n\nArguments\n\n\nLnumpy.ndarray\n\n\nValues for the L dimension.\n\n\nUnumpy.ndarray\n\n\nValues for the U dimension.\n\n\nVnumpy.ndarray\n\n\nValues for the V dimension.\n\n\n\n\nReturn\nReturns corresponding polar LUV chromaticities as a list of numpy.ndarrays of the same length as the inputs ([L, A, B]), also known as [H, C, L] coordinates."
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.get.html",
    "href": "man/colorspace.palettes.diverging_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\ndiverging_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hsv.specplot.html",
    "href": "man/colorspace.palettes.diverging_hsv.specplot.html",
    "title": "Color Spectrum Plot",
    "section": "",
    "text": "Description\nInterfacing the colorspace.specplot.specplot function. Plotting the spectrum of the current color palette.\n\n\nUsage\ndiverging_hsv.specplot(n=180, *args, **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors, defaults to 180.\n\n\n*args\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n**kwargs\n\n\nForwarded to colorspace.specplot.specplot.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl\npal = diverging_hcl()\npal.specplot()\npal.specplot(rgb = False)"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.get_whitepoint.html",
    "href": "man/colorspace.colorlib.CIELAB.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nCIELAB.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.cmap.html",
    "href": "man/colorspace.palettes.qualitative_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\nqualitative_hcl.cmap(n=101,                     name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.to.html",
    "href": "man/colorspace.colorlib.polarLUV.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\npolarLUV.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.palettes.palette.cmap.html",
    "href": "man/colorspace.palettes.palette.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nConverts the current palette into a matplotlib.colors.LinearSegmentedColormap color map. If input argument n = None the color map will provide the same number of colors as defined for this palette. Can also be set higher to allow matplotlib to interpolate between the colors.\n\n\nUsage\npalette.cmap(n=None, rev=False)\n\n\nArguments\n\n\nnNone or int\n\n\nNone or a positive int which is greater or equal to the number of colors of the palette (check len() of the object).\n\n\nrevbool\n\n\nIf set to True the color map will be reversed, defaults to False.\n\n\n\n\nExamples\n\nfrom colorspace import diverging_hcl, palette\npal = diverging_hcl()\npal = palette(pal(5), name = \"Diverging Palette with 5 Colors\")\ncmap = pal.cmap()\nprint(type(cmap))\nprint(cmap.N)\ncmap2 = pal.cmap(n = 256)\nprint(cmap2.N)\n\n&lt;class 'matplotlib.colors.LinearSegmentedColormap'&gt;\n5\n256"
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.show_settings.html",
    "href": "man/colorspace.palettes.qualitative_hcl.show_settings.html",
    "title": "Show Palette Settings",
    "section": "",
    "text": "Description\nShows the current settings (table like print to stdout). Should more be seen as a development method than a very useful thing.\n\n\nUsage\nqualitative_hcl.show_settings()\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl(10)\na.show_settings()\n\nClass:  rainbow_hcl\nh1             0\nh2      &lt;lambda&gt;\nc1            10\nc2           ---\ncmax         ---\nl1            70\nl2           ---\np1           ---\np2           ---\nfixup       True"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.RAD2DEG.html",
    "href": "man/colorspace.colorlib.colorlib.RAD2DEG.html",
    "title": "Convert radiant to degrees",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\ncolorlib.RAD2DEG(x)\n\n\nArguments\n\n\nxfloat, array of floats\n\n\nValue(s) in radiant.\n\n\n\n\nReturn\nfloat, array of floats: Returns input x in degrees."
  },
  {
    "objectID": "man/colorspace.utils.contrast_ratio.html",
    "href": "man/colorspace.utils.contrast_ratio.html",
    "title": "W3C Contrast Ratio",
    "section": "",
    "text": "Description\nCompute (and visualize) the contrast ratio of pairs of colors, as defined by the World Wide Web Consortium (W3C). Requires matplotlib to be installed.\nThe W3C Content Accessibility Guidelines (WCAG) recommend a contrast ratio of at least 4.5 for the color of regular text on the background color, and a ratio of at least 3 for large text. See https://www.w3.org/TR/WCAG21/#contrast-minimum.\nThe contrast ratio is defined in https://www.w3.org/TR/WCAG21/#dfn-contrast-ratio as (L1 + 0.05) / (L2 + 0.05) where L1 and L2 are the relative luminances (see https://www.w3.org/TR/WCAG21/#dfn-relative-luminance) of the lighter and darker colors, respectively. The relative luminances are weighted sums of scaled sRGB coordinates: 0.2126 * R + 0.7152 * G + 0.0722 * B where each of R, G, and B is defined as RGB / 12.92 if RGB &lt;= 0.03928 else (RGB + 0.055)/1.055)^2.4 based on the RGB coordinates between 0 and 1.\n\n\nUsage\ncontrast_ratio(colors, bg='#FFFFFF',               plot=False, ax=None,               fontsize='xx-large',               fontweight='heavy',               ha='center',               va='center', **kwargs)\n\n\nArguments\n\n\ncolorsstr, list, colorobject, palette\n\n\nSingle hex color (str), a list of hex colors (list), a color object , or palette.\n\n\nbgstr\n\n\nbackground color against which the contrast will be calculated. Defaults to white (\"#FFFFFF\").\n\n\nplotbool\n\n\nlogical indicating whether the contrast ratios should also be visualized by simple color swatches.\n\n\naxNone or matplotlib.axes.Axes\n\n\nIf None, a new matplotlib figure will be created. If ax inherits from matplotlib.axes.Axes this object will be used to create the demoplot. Handy to create multiple subplots. Forwarded to different plot types.\n\n\nfontsizefloat, str\n\n\nsize of text, forwarded to matplotlib.pyplot.text. Defaults to \"xx-large\".\n\n\nfontweightstr\n\n\nweight of text, forwarded to matplotlib.pyplot.text. Defaults to \"heavy\".\n\n\nhastr\n\n\nhorizontal alignment, forwarded to matplotlib.pyplot.text. Defaults to \"center\".\n\n\nvastr\n\n\nvertical alignment, forwarded to matplotlib.pyplot.text. Defaults to \"center\".\n\n\n**kwargs\n\n\nAllows to specify figsize forwarded to maptlotlib.pyplot.figure, only used if ax is None.\n\n\n\n\nReturn\nA numeric vector with the contrast ratios is returned (invisibly, if plot is True).\n\n\nExamples\n\n# check contrast ratio of default palette on white background\nfrom colorspace import rainbow, contrast_ratio\ncolors = rainbow().colors(7)\ncontrast_ratio(colors, \"#FFFFFF\") # Against white\ncontrast_ratio(colors, \"#000000\") # Against black\n\narray([ 5.252     , 15.38460716, 15.58729349, 15.71906457,  6.55555374,\n        2.72729349,  6.27489463])\n\n\n\n# Visualize contrast ratio against white\ncontrast_ratio(colors, \"#FFFFFF\", plot = True);\n\n\n\n\n\n\n\n\n\n# Visualize contrast ratio against black\ncontrast_ratio(colors, \"#000000\", plot = True);\n\n\n\n\n\n\n\n\n\n# Changing figure size\ncontrast_ratio(colors, \"#000000\", plot = True, figsize = (4, 3));\n\n\n\n\n\n\n\n\n\n\nRaises\n\n\nTypeError: If cols or bg is not one of the recognized types.\n\nTypeError: If argument plot is not bool.\n\nTypeError: If ax is not None or a matplotlib.axes.Axes object. Only checked if plot = True.",
    "crumbs": [
      "Home",
      "Function references",
      "contrast_ratio"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.palette.rename.html",
    "href": "man/colorspace.palettes.palette.rename.html",
    "title": "Rename Custom Palette",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\npalette.rename(name)\n\n\nArguments\n\n\nnameNone, str\n\n\nnew name for the palette.\n\n\n\n\nRaises\n\n\nValueError: If input 'name' is not of type str."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.length.html",
    "href": "man/colorspace.colorlib.CIELUV.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nCIELUV.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.set.html",
    "href": "man/colorspace.colorlib.HLS.set.html",
    "title": "Set/Manipulate Colors",
    "section": "",
    "text": "Description\nAllows to manipulate the current colors. The named input arguments have to fulfil a specific set or requirements. If not, the function raises exceptions. The requirements:\n\nDimension has to exist\nNew data/values must be of same length and type as the existing ones\n\n\n\nUsage\nHLS.set(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. The key is the name of the dimension to be changed, the value an object which fulfills the requirements (see description of this method)\n\n\n\n\nReturn\nNo return, modifies the current color object.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  260.00   80.00   30.00\n       80.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\ncols.set(H = [150, 150, 30])\nprint(cols)\n\npolarLUV color object (3 colors)\n           H       C       L\n  1:  150.00   80.00   30.00\n      150.00    0.00   90.00\n       30.00   80.00   30.00\n\n\n\n\nRaises\n\n\nValueError: If the dimension does not exist.\n\nValueError: If the new data can't be converted into numpy.array (is done automatically if needed).\n\nValueError: If new data has wrong length (does not match the number of colors/length of current values)."
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.length.html",
    "href": "man/colorspace.colorlib.HSV.length.html",
    "title": "Get Number of Colors",
    "section": "",
    "text": "Description\nReturns the number of colors defined in this color object.\nReturn: int: Number of colors defined.\n\n\nUsage\nHSV.length()"
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.get_whitepoint.html",
    "href": "man/colorspace.colorlib.sRGB.get_whitepoint.html",
    "title": "Get White Point",
    "section": "",
    "text": "Description\nThis method returns the definition of the white point in use. If not explicitly set via the set_whitepoint method, a default white point is used.\n\n\nUsage\nsRGB.get_whitepoint()\n\n\nReturn\nReturns a dict with X, Y, Z, the white point specification for the three dimensions.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.get_whitepoint()\n\n{'X': 95.047, 'Y': 100.0, 'Z': 108.883}"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.LAB_to_XYZ.html",
    "href": "man/colorspace.colorlib.colorlib.LAB_to_XYZ.html",
    "title": "Convert CIELAB to CIEXYZ",
    "section": "",
    "text": "Description\nL, A, and B specify the values in the three coordinates of the CIELAB color space, XN, YN, and ZN allow to specify additional CIE chromaticities to specify a specific white point.\n\n\nUsage\ncolorlib.LAB_to_XYZ(L, A, B, XN=None, YN=None,                    ZN=None)\n\n\nArguments\n\n\nLnumpy.ndarray\n\n\nValues for the L dimension.\n\n\nAnumpy.ndarray\n\n\nValues for the A dimension.\n\n\nBnumpy.ndarray\n\n\nValues for the B dimension.\n\n\nXNNone, numpy.ndarray\n\n\nChromaticity of the white point. If of length 1, the white point specification will be recycled if needed. When not specified (all None) a default white point is used.\n\n\nYN\n\n\nSee XN.\n\n\nZN\n\n\nSee XN.\n\n\n\n\nReturn\nReturns corresponding coordinates of CIE chromaticities as a list of numpy.ndarrays of the same length as the inputs ([X, Y, Z])."
  },
  {
    "objectID": "man/colorspace.colorlib.polarLUV.swatchplot.html",
    "href": "man/colorspace.colorlib.polarLUV.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\npolarLUV.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.to.html",
    "href": "man/colorspace.colorlib.CIEXYZ.to.html",
    "title": "Transform Color Space",
    "section": "",
    "text": "Description\nAllows to transform the current object into a different color space, if possible.\n\n\nUsage\nCIEXYZ.to(to, fixup=True)\n\n\nArguments\n\n\ntostr\n\n\nName of the color space into which the colors should be converted (e.g., CIEXYZ, HCL, hex, RGB, …)\n\n\nfixupbool\n\n\nWhether or not colors outside the defined rgb color space should be corrected if necessary, defaults to True.\n\n\n\n\nReturn\nNo return, converts the object into a new color space and modifies the underlying object. After calling this method the object will be of a different class."
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.gtrans.html",
    "href": "man/colorspace.colorlib.colorlib.gtrans.html",
    "title": "Gamma Correction",
    "section": "",
    "text": "Description\nFunction gtrans and ftrans provide gamma correction which can be used to switch between sRGB and linearised sRGB (RGB).\nThe standard value of gamma for sRGB displays is approximately 2.2, but more accurately is a combination of a linear transform and a power transform with exponent 2.4. gtrans maps linearised sRGB to sRGB, ftrans provides the inverse mapping.\n\n\nUsage\ncolorlib.gtrans(u, gamma)\n\n\nArguments\n\n\nunumpy.ndarray\n\n\nFloat array of length N.\n\n\ngammafloat, numpy.ndarray\n\n\ngamma value; if float or numpy.ndarray of length one, gamma will be recycled if needed.\n\n\n\n\nReturn\nGamma corrected values, same length as input u."
  },
  {
    "objectID": "man/colorspace.palettes.qualitative_hcl.html",
    "href": "man/colorspace.palettes.qualitative_hcl.html",
    "title": "Qualitative HCL Color Palettes",
    "section": "",
    "text": "Description\nSee also: sequential_hcl, diverging_hcl, divergingx_hcl, rainbow_hcl, heat_hcl, terrain_hcl, diverging_hsv, and rainbow.\nArgument h uses a list with [0, lambda x: 360. * (n - 1.) / n] by default such that the colors drawn from the palet are uniformly distributed around the circle ([0., 360.]).\n\n\nUsage\nqualitative_hcl(h=[0, &lt;function qualitative_hcl.&lt;lambda&gt; at 0x7b1b25c7fba0&gt;],                c=80, l=60, fixup=True,                palette=None, rev=False, **kwargs)\n\n\nArguments\n\n\nhint, float, list\n\n\nHue values defining the ‘color’. Qualitative color palettes require two hues. If more than two values are provided the first two will be used while the rest is ignored. If input h is a str this argument acts like the palette argument (see palette input parameter). Can also be lambda functions or a list of lambda functions which take up one single argument n (number of colors; see default value).\n\n\ncint, float\n\n\nChroma value (colorfullness), a single numeric value. If multiple values are provided only the first one will be used.\n\n\nlint, float\n\n\nluminance value (lightness), a single numeric value. If multiple values are provided only the first one will be used.\n\n\nfixupbool\n\n\nOnly used when converting the HCL colors to hex. Should RGB values outside the defined RGB color space be corrected?\n\n\npaletteNone, str\n\n\nCan be used to load a default diverging color qpalette specification. If the palette does not exist an exception will be qraised. Else the settings of the palette as defined will be used to create qthe color palette.\n\n\nrevbool\n\n\nShould the color map be reversed? Default False.\n\n\n**kwargs\n\n\nAdditional arguments to overwrite the h/c/l settings. TODO: has to be documented.\n\n\n\n\nReturn\nInitialize new object. Raises exceptions if the parameters are misspecified. Note that the object is callable, the default object call can be used to return hex colors (identical to the .colors() method), see examples.\n\n\nMethods\n\n\nqualitative_hcl.cmap(n=101, name='custom_hcl_cmap')\n\n\nGet matplotlib Compatible Color Map\n\n\nqualitative_hcl.colors(n=11, fixup=None, **kwargs)\n\n\nGet Colors\n\n\nqualitative_hcl.get(key)\n\n\nGet Specific Palette Setting\n\n\nqualitative_hcl.name()\n\n\nGet Palette Name\n\n\nqualitative_hcl.show_settings()\n\n\nShow Palette Settings\n\n\nqualitative_hcl.specplot(n=180, *args, **kwargs)\n\n\nColor Spectrum Plot\n\n\nqualitative_hcl.swatchplot(n=7, **kwargs)\n\n\nPalette Swatch Plot\n\n\n\n\nExamples\n\nfrom colorspace import qualitative_hcl\na = qualitative_hcl()\na.colors(10)\n\n['#E16A86',\n '#CE7D3B',\n '#AA9000',\n '#6F9F00',\n '#00AA5A',\n '#00AD9A',\n '#00A6CA',\n '#5991E4',\n '#B675E0',\n '#DD64BE']\n\n\n\nb = qualitative_hcl(\"Warm\")\nb.colors(10)\n\n['#ABB065',\n '#B8AC65',\n '#C4A86A',\n '#CFA373',\n '#D79F7F',\n '#DE9B8C',\n '#E2979A',\n '#E495A8',\n '#E393B6',\n '#E093C3']\n\n\n\nb.swatchplot(show_names = False, figsize = (5.5, 0.5));\n\n\n\n\n\n\n\n\n\n# The standard call of the object also returns hex colors\nqualitative_hcl(\"Warm\")(10)\n\n['#ABB065',\n '#B8AC65',\n '#C4A86A',\n '#CFA373',\n '#D79F7F',\n '#DE9B8C',\n '#E2979A',\n '#E495A8',\n '#E393B6',\n '#E093C3']\n\n\n\n\nRaises\n\n\nTypeError: If h is not a single int or float, or a list (see next).\n\nTypeError: If h is a list but not all elements are of type int, float, or callable (lambda functions).",
    "crumbs": [
      "Home",
      "Class references",
      "qualitative_hcl"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIEXYZ.get.html",
    "href": "man/colorspace.colorlib.CIEXYZ.get.html",
    "title": "Extracting Color Coordinates",
    "section": "",
    "text": "Description\nExtracts and returns the current values of a all or one specific coordinate for all colors of this color object.\n\n\nUsage\nCIEXYZ.get(dimname=None)\n\n\nArguments\n\n\ndimnameNone, str\n\n\nIf None (default) values of all coordinates of the current color object are returned. A specific coordinate can be specified if needed.\n\n\n\n\nReturn\ndict, numpy.ndarray: If argument dimname = None a dictionary is returned containing the values of all colors for all coordinates of the current color space, each entry of the dictionary is a numpy.ndarray. When a specific dimension is requested, a single numpy.ndarray is returned.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([260, 80, 30], [80, 0, 80], [30, 90, 30])\ncols.get()\ncols.get(\"H\")\n\narray([260.,  80.,  30.])\n\n\n\n\nRaises\n\n\nTypeError: If dimname is neither None or str.\n\nValueError: If the dimension specified on dimnames does not exist."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.swatchplot.html",
    "href": "man/colorspace.colorlib.CIELUV.swatchplot.html",
    "title": "Palette Swatch Plot",
    "section": "",
    "text": "Description\nVisualization the color palette of this color object. Internally calls specplot, additional arguments to this main function can be forwarded via the **kwargs argument.\n\n\nUsage\nCIELUV.swatchplot(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nAdditional named arguments forwarded to swatchplot.\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL(H = [160, 210, 260, 310, 360],\n           C = [ 70,  40,  10,  40,  70],\n           L = [ 50,  70,  90,  70,  50])\ncols.swatchplot();\ncols.swatchplot(figsize = (6, 0.5));"
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.html",
    "href": "man/colorspace.colorlib.CIELUV.html",
    "title": "Create CIELUV Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the CIELUV color space. Can be converted to: CIEXYZ, CIELUV, CIELAB, RGB, sRGB, polarLAB, and hexcols. Not allowed (ambiguous) are transformations to HSV and HLS.\n\n\nUsage\nCIELUV(L, U, V, alpha=None)\n\n\nArguments\n\n\nLint, float, list, numpy.array\n\n\nNumeric value(s) for L dimension.\n\n\nUint, float, list, numpy.array\n\n\nNumeric value(s) for U dimension.\n\n\nVint, float, list, numpy.array\n\n\nNumeric value(s) for L dimension.\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\nCIELUV.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nCIELUV.dropalpha()\n\n\nRemove Alpha Channel\n\n\nCIELUV.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nCIELUV.get_whitepoint()\n\n\nGet White Point\n\n\nCIELUV.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nCIELUV.length()\n\n\nGet Number of Colors\n\n\nCIELUV.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nCIELUV.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nCIELUV.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nCIELUV.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nCIELUV.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\nfrom colorspace.colorlib import CIELUV\n# Constructing color object with one single color via float\nCIELUV(0, 10, 10)\n\nCIELUV color object (1 colors)\n           L       U       V\n  1:    0.00   10.00   10.00\n\n\n\n# Constructing object via lists\nCIELUV([10, 30], [20, 80], [100, 40])\n\nCIELUV color object (2 colors)\n           L       U       V\n  1:   10.00   20.00  100.00\n       30.00   80.00   40.00\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\nCIELUV(asarray([10, 30]), asarray([20, 80]), asarray([100, 40]))\n\nCIELUV color object (2 colors)\n           L       U       V\n  1:   10.00   20.00  100.00\n       30.00   80.00   40.00",
    "crumbs": [
      "Home",
      "Class references",
      "CIELUV"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.diverging_hcl.colors.html",
    "href": "man/colorspace.palettes.diverging_hcl.colors.html",
    "title": "Get Colors",
    "section": "",
    "text": "Description\nReturns the colors of the current color palette.\n\n\nUsage\ndiverging_hcl.colors(n=11, fixup=True, alpha=None,                     **kwargs)\n\n\nArguments\n\n\nnint\n\n\nNumber of colors which should be returned.\n\n\nfixupNone, bool\n\n\nShould sRGB colors be corrected if they lie outside the defined color space? If None the fixup parameter from the object will be used. Can be set to True or False to explicitly control the fixup here.\n\n\nalphaNone, float\n\n\nFloat (single value) or vector of floats in the range of [0.,1.] for alpha transparency channel (0. means full transparency, 1. opaque). If a single value is provided it will be applied to all colors, if a vector is given the length has to be n.\n\n\n**kwargs\n\n\nCurrently allows for rev = True to reverse the colors and colorobject = 'anything' to get HCL colors as return."
  },
  {
    "objectID": "man/colorspace.colorlib.CIELAB.dropalpha.html",
    "href": "man/colorspace.colorlib.CIELAB.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nCIELAB.dropalpha()"
  },
  {
    "objectID": "man/colorspace.CVD.deutan.html",
    "href": "man/colorspace.CVD.deutan.html",
    "title": "Simulate Color Vision Deficiency",
    "section": "",
    "text": "Description\nTransformation of colors by simulating color vision deficiencies, based on a CVD transform matrix. This function is an interface to the CVD object and returns simulated colors for deuteranope vision (green-yellow-red weakness).\nSee also protan, tritan, desaturate, and cvd_emulator.\n\n\nUsage\ndeutan(cols, severity=1.0, linear=True)\n\n\nArguments\n\n\ncolslist, colorobject, matplotlib.colors.LinearSegmentedColormap\n\n\nSingle hex color, list of hex colors (str), a matoplotlib cmap, or a color color object (such as RGB, hexcols, CIELUV).\n\n\nseverityfloat\n\n\nSeverity in [0., 1.]. Zero means no deficiency, one maximum deficiency, defaults to 1..\n\n\nlinearbool\n\n\nShould the color vision deficiency transformation be applied to the linearised RGB coordinates (default)? If False, the transformation is applied to the gamma-corrected sRGB coordinates (as in the Machado et al. 2009 supplementary materials).\n\n\n\n\nReturn\nReturns an object of the same type as the input object cols with modified colors as people with deuteranomaly see these colors (simulated).\n\n\nExamples\n\nfrom colorspace import rainbow_hcl, deutan, palette\nfrom colorspace import specplot, swatchplot\n# Drawing 100 colors along the HCL rainbow color palette\ncols = rainbow_hcl()(100)\nspecplot(cols);\n\n\n\n\n\n\n\n\n\nspecplot(deutan(cols));\n\n\n\n\n\n\n\n\n\nspecplot(deutan(cols, 0.5));\n\n\n\n\n\n\n\n\n\n# List of (hex) colors\ncols = [\"magenta\", \"red\", \"orange\", \"#F2F204\", \"#6BF204\", \"#4DA00D\"]\ndeutan(cols);\n\n\n# Visualize original and simulated color swatches\nswatchplot([cols, deutan(cols)],\n           show_names = False, figsize = (5, 1.5));\n\n\n\n\n\n\n\n\n\n# From palette object\npal = palette(cols, name = \"custom palette\")\ndeutan(pal)\n\n['#689BFA', '#A39000', '#D9C10E', '#FFED2F', '#E9D137', '#9B8B25']\n\n\n\n# From cmap (returns cmap)\ndeutan(pal.cmap())\n\ncustom palette  underbad over",
    "crumbs": [
      "Home",
      "Function references",
      "deutan"
    ]
  },
  {
    "objectID": "man/colorspace.palettes.rainbow_hcl.cmap.html",
    "href": "man/colorspace.palettes.rainbow_hcl.cmap.html",
    "title": "Get matplotlib Compatible Color Map",
    "section": "",
    "text": "Description\nAllows to retrieve a matplotlib LinearSegmentedColormap color map. Clasically LinearSegmentedColormaps allow to retrieve a set of N colors from a set of n colors where N &gt;&gt; n. The matplotlib simply linearely interpolates between all n colors to extend the number of colors to N.\nIn case of hclpalette objects this is not necessary as hclpalette objects allow to retrieve N colors directly along well-specified Hue-Chroma-Luminance paths. Thus, this method returns a matplotlib color map with n = N colors. The linear interpolation between the colors (as typically done by LinearSegmentedColormap) is not necessary. However, for convenience cmaps have been implemented such that you can easily use hcl based palettes in your existing workflow.\n\n\nUsage\nrainbow_hcl.cmap(n=101,                 name='custom_hcl_cmap')\n\n\nArguments\n\n\nnint\n\n\nNumber of colors the cmap should be based on; default is n = 101.\n\n\nnamestr\n\n\nName of the custom color map. Default is custom_hcl_cmap\n\n\n\n\nReturn\nReturns a LinearSegmentedColormap (cmap) to be used with the matplotlib library."
  },
  {
    "objectID": "man/colorspace.colorlib.RGB.colors.html",
    "href": "man/colorspace.colorlib.RGB.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nRGB.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.colorlib.sRGB.colors.html",
    "href": "man/colorspace.colorlib.sRGB.colors.html",
    "title": "Extract Hex Colors",
    "section": "",
    "text": "Description\nReturns hex colors of the current color object by converting the current color object into an object of class hexcols.\nIf the object contains alpha values, the alpha level is added to the hex string if and only if alpha is not equal to 1.0.\n\n\nUsage\nsRGB.colors(fixup=True, rev=False)\n\n\nArguments\n\n\nfixupbool\n\n\nWhether or not to correct rgb values outside the defined range of [0., 1.], defaults to True.\n\n\nrevbool\n\n\nShould the color palette be reversed? Defaults to False.\n\n\n\n\nReturn\nReturns a list of hex color strings.\n\n\nExamples\n\nfrom colorspace.colorlib import HCL\ncols = HCL([0, 40, 80], [30, 60, 80], [85, 60, 35])\ncols.colors()\n\n['#FAC8D1', '#C08353', '#5F5500']"
  },
  {
    "objectID": "man/colorspace.palettes.divergingx_hcl.get.html",
    "href": "man/colorspace.palettes.divergingx_hcl.get.html",
    "title": "Get Specific Palette Setting",
    "section": "",
    "text": "Description\nReturns one specific item of the palette settings, e.g., the current value for h1 or l2. If not existing a None will be returned.\n\n\nUsage\ndivergingx_hcl.get(key)\n\n\nArguments\n\n\nkeystr\n\n\nName of the setting to be returned.\n\n\n\n\nReturn\nNone if key does ont exist, else the current value will be returned.\n\n\nExamples\n\nfrom colorspace.palettes import rainbow_hcl\na = rainbow_hcl()\na.get(\"h1\")\na.get(\"c1\")\na.get(\"l1\")\na.get(\"not_defined\")"
  },
  {
    "objectID": "man/colorspace.colorlib.colorlib.XYZ_to_LUV.html",
    "href": "man/colorspace.colorlib.colorlib.XYZ_to_LUV.html",
    "title": "Convert CIEXYZ to CIELUV.",
    "section": "",
    "text": "Description\nX, Y, and Z specify the values in the three coordinates of the CIELAB color space, XN, YN, and ZN allow to specify additional CIE chromaticities to specify a specific white point.\n\n\nUsage\ncolorlib.XYZ_to_LUV(X, Y, Z, XN=None, YN=None,                    ZN=None)\n\n\nArguments\n\n\nXnumpy.ndarray\n\n\nValues for the X dimension.\n\n\nYnumpy.ndarray\n\n\nValues for the Y dimension.\n\n\nZnumpy.ndarray\n\n\nValues for the Z dimension.\n\n\nXNNone, numpy.ndarray\n\n\nChromaticity of the white point. If of length 1, the white point specification will be recycled if needed. When not specified (all None) a default white point is used.\n\n\nYN\n\n\nSee XN.\n\n\nZN\n\n\nSee XN.\n\n\n\n\nReturn\nReturns corresponding coordinates of CIE chromaticities as a list of numpy.ndarrays of the same length as the inputs ([L, U, V])."
  },
  {
    "objectID": "man/colorspace.colorlib.HLS.set_whitepoint.html",
    "href": "man/colorspace.colorlib.HLS.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nHLS.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.HSV.html",
    "href": "man/colorspace.colorlib.HSV.html",
    "title": "Create HSV Color Object",
    "section": "",
    "text": "Description\nCreates a color object in the Hue-Saturation-Value (HSV) color space. Can be converted to: RGB, sRGB, HLS, and hexcols. Not allowed (ambiguous) are transformations to CIEXYZ, CIELUV, CIELAB, polarLUV, and polarLAB.\n\n\nUsage\nHSV(H, S, V, alpha=None)\n\n\nArguments\n\n\nHint, float, list, numpy.array\n\n\nNumeric value(s) for Hue dimension.\n\n\nSint, float, list, numpy.array\n\n\nNumeric value(s) for Saturation dimension.\n\n\nVint, float, list, numpy.array\n\n\nNumeric value(s) for Value dimension.\n\n\nalphaNone, float, list, numpy.array\n\n\nNumeric value(s) for the alpha channel ([0., 1.]) where 0. equals full transparency, 1. full opacity. If None (default) no transparency is added.\n\n\n\n\nMethods\n\n\nHSV.colors(fixup=True, rev=False)\n\n\nExtract Hex Colors\n\n\nHSV.dropalpha()\n\n\nRemove Alpha Channel\n\n\nHSV.get(dimname=None)\n\n\nExtracting Color Coordinates\n\n\nHSV.get_whitepoint()\n\n\nGet White Point\n\n\nHSV.hasalpha()\n\n\nCheck for Alpha Channel\n\n\nHSV.length()\n\n\nGet Number of Colors\n\n\nHSV.set(**kwargs)\n\n\nSet/Manipulate Colors\n\n\nHSV.set_whitepoint(**kwargs)\n\n\nSet White Point\n\n\nHSV.specplot(**kwargs)\n\n\nColor Spectrum Plot\n\n\nHSV.swatchplot(**kwargs)\n\n\nPalette Swatch Plot\n\n\nHSV.to(to, fixup=True)\n\n\nTransform Color Space\n\n\n\n\nExamples\n\n# Constructing object via numpy arrays\nfrom colorspace.colorlib import HSV\n# Constructing color object with one single color via float\nHSV(150, 150, 10)\n\nHSV color object (1 colors)\n           H       S       V\n  1:  150.00  150.00   10.00\n\n\n\n# Constructing object via lists\nHSV([150, 150, 10], [1.5, 0, 1.5], [0.1, 0.7, 0.1])\n\nHSV color object (3 colors)\n           H       S       V\n  1:  150.00    1.50    0.10\n      150.00    0.00    0.70\n       10.00    1.50    0.10\n\n\n\n# Constructing object via numpy arrays\nfrom numpy import asarray\ncols = HSV(asarray([150, 150, 150]),\n           asarray([1.5, 0, 1.5]),\n           asarray([0.1, 0.7, 0.1]))\ncols\n\nHSV color object (3 colors)\n           H       S       V\n  1:  150.00    1.50    0.10\n      150.00    0.00    0.70\n      150.00    1.50    0.10\n\n\n\n# Converting to RGB\ncols.to(\"RGB\")\ncols\n\nRGB color object (3 colors)\n           R       G       B\n  1:   -0.00    0.01    0.00\n        0.45    0.45    0.45\n       -0.00    0.01    0.00",
    "crumbs": [
      "Home",
      "Class references",
      "HSV"
    ]
  },
  {
    "objectID": "man/colorspace.colorlib.CIELUV.set_whitepoint.html",
    "href": "man/colorspace.colorlib.CIELUV.set_whitepoint.html",
    "title": "Set White Point",
    "section": "",
    "text": "Description\nA white point definition is used to adjust the colors. This method allows to set custom values. If not explicitly set a default specification is used. The get_whitepoint method can be used to extract the currently used definition.\n\n\nUsage\nCIELUV.set_whitepoint(**kwargs)\n\n\nArguments\n\n\n**kwargs\n\n\nNamed arguments. Allowed are X, Y, and Z, each of which must be float: White specification for dimension X/Y/Z.\n\n\n\n\nReturn\nNo return, stores the new definition on the object.\n\n\nExamples\n\nfrom colorspace.colorlib import hexcols\nc = hexcols(\"#ff0000\")\nc.set_whitepoint(X = 100., Y = 100., Z = 101.)\nc.get_whitepoint()\n\n{'X': 100.0, 'Y': 100.0, 'Z': 101.0}"
  },
  {
    "objectID": "man/colorspace.colorlib.hexcols.dropalpha.html",
    "href": "man/colorspace.colorlib.hexcols.dropalpha.html",
    "title": "Remove Alpha Channel",
    "section": "",
    "text": "Description\nRemove alpha channel from the color object, if defined (see hasalpha).\n\n\nUsage\nhexcols.dropalpha()"
  },
  {
    "objectID": "man/colorspace.palettes.palette.name.html",
    "href": "man/colorspace.palettes.palette.name.html",
    "title": "Get Palette Name",
    "section": "",
    "text": "WARNING(long_description missing)\n\nUsage\npalette.name()\n\n\nReturn\nNone, str: Name of the palette (if set)."
  },
  {
    "objectID": "articles/endrainbow.html",
    "href": "articles/endrainbow.html",
    "title": "Somewhere over the Rainbow",
    "section": "",
    "text": "The go-to palette in many software packages is - or used to be until rather recently - the so-called rainbow: a palette created by changing the hue in highly-saturated RGB colors. This has been widely recognized as having a number of disadvantages including: abrupt shifts in brightness, misleading for viewers with color vision deficiencies, too flashy to look at for a longer time. See also the article on color vision deficiencies which compares the infamous RGB rainbow with better HCL-based alternatives using demoplot. Here, we provide further rainbow examples taken from actual publications (rather than simplified demos).\nFor more details on the limitations of the rainbow palette and further pointers see “The End of the Rainbow” by Hawkins et al. (2014), “Examining Implicit Discretization in Spectral Schemes” by Quinan et al. (2019), or “Somewhere over the Rainbow: How to Make Effective Use of Colors in Meteorological Visualizations” by Stauffer et al. (2015) as well as the #endrainbow hashtag on X (twitter).\nIn a nutshell, the (in-)famous RGB rainbow palette is virtually always a poor choice and properly balanced qualitative, sequential, or diverging palettes - such as the HCL-Based Color Palettes provided here - are preferable. Despite such alternatives becoming more and more widely available the rainbow palette is unfortunately still widely used. Below we illustrate some wild-caught examples, highlight their problems (e.g., by desaturation to grayscale or by emulating color vision deficiencies), and suggest better alternatives."
  },
  {
    "objectID": "articles/endrainbow.html#overview",
    "href": "articles/endrainbow.html#overview",
    "title": "Somewhere over the Rainbow",
    "section": "",
    "text": "The go-to palette in many software packages is - or used to be until rather recently - the so-called rainbow: a palette created by changing the hue in highly-saturated RGB colors. This has been widely recognized as having a number of disadvantages including: abrupt shifts in brightness, misleading for viewers with color vision deficiencies, too flashy to look at for a longer time. See also the article on color vision deficiencies which compares the infamous RGB rainbow with better HCL-based alternatives using demoplot. Here, we provide further rainbow examples taken from actual publications (rather than simplified demos).\nFor more details on the limitations of the rainbow palette and further pointers see “The End of the Rainbow” by Hawkins et al. (2014), “Examining Implicit Discretization in Spectral Schemes” by Quinan et al. (2019), or “Somewhere over the Rainbow: How to Make Effective Use of Colors in Meteorological Visualizations” by Stauffer et al. (2015) as well as the #endrainbow hashtag on X (twitter).\nIn a nutshell, the (in-)famous RGB rainbow palette is virtually always a poor choice and properly balanced qualitative, sequential, or diverging palettes - such as the HCL-Based Color Palettes provided here - are preferable. Despite such alternatives becoming more and more widely available the rainbow palette is unfortunately still widely used. Below we illustrate some wild-caught examples, highlight their problems (e.g., by desaturation to grayscale or by emulating color vision deficiencies), and suggest better alternatives."
  },
  {
    "objectID": "articles/endrainbow.html#would-bob-ross-approve",
    "href": "articles/endrainbow.html#would-bob-ross-approve",
    "title": "Somewhere over the Rainbow",
    "section": "Would Bob Ross approve?",
    "text": "Would Bob Ross approve?\nWhen you see a (scientific) data visualization with a rainbow, ask yourself: Would Bob Ross approve of this?\n\nMost likely not. In contrast, choosing a HCL-based palette instead will yield less flashy colors that change smoothly … very much in the spirit of The Joy of Painting."
  },
  {
    "objectID": "articles/endrainbow.html#heatmap-from-the-grammar-of-graphics",
    "href": "articles/endrainbow.html#heatmap-from-the-grammar-of-graphics",
    "title": "Somewhere over the Rainbow",
    "section": "Heatmap from The Grammar of Graphics",
    "text": "Heatmap from The Grammar of Graphics\nEven in the excellent book “The Grammar of Graphics” by Wilkinson (2005), the rainbow palette is used in one of the first figures, depicting a heatmap of a bivariate kernel density estimate. The figure is shown below on the left and is contrasted with an HCL-based sequential heat color palette on the right (sequential_hcl(\"Heat\")(99)).\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe original palette changes back and forth between dark and light colors and hence high- and low-density regions are difficult to tell apart, especially when desaturated to grayscale. In contrast, the heat colors go from light to dark and still work very well in grayscale.\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, high- and low-density regions are much harder to distinguish for colorblind viewers in the original rainbow palette compared to the heat colors. Below deuteranope vision is emulated."
  },
  {
    "objectID": "articles/endrainbow.html#map-of-model-deviations",
    "href": "articles/endrainbow.html#map-of-model-deviations",
    "title": "Somewhere over the Rainbow",
    "section": "Map of model deviations",
    "text": "Map of model deviations\nOften a subset of the RGB rainbow palette is used as a “traffic light”, coding “positive” (green) and “negative” (red) deviations from some neutral value (yellow), e.g., forecast errors or other model deviations, correlations, slopes, etc. A typical example is shown below, taken from Figure 5 of Kneib (2006), where deviations from a childhood moratlity model (without spatial effect) for Nigeria are depicted.\nThe original palette is rainbow(start = 0, end = 1/3, rev = True)(99) (left) and as a better alternative diverging_hcl(\"Purple-Green\", rev = True)(99) is used. This avoids the flashy colors and uses light gray as the neutral value, making it easier to look at the display for a longer time. Instead of diverging to red/green the palette diverges to purple/green as this works better for colorblind viewers (see below).\n\n\n\n\n\n\n\n\n\n\n\n\n\nEmulating protanope vision most of the green-yellow contrasts in the RGB rainbow are collpased, making the plot very misleading while the HCL-based purple/green palette still works very well for colorblind viewers.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnother important difference between the two palettes is that the HCL-based alternative is completely balanced between the two “arms” of the palette while the rainbow is not. Specifically, the green arm has an almost flat luminance trajectory while the red arm reaches much lower luminances (i.e., darker colors).\n\nfrom colorspace import rainbow, specplot\npal = rainbow(start = 0, end = 1/3, rev = True)\nspecplot(pal(99));\n\n\n\n\n\n\n\n\n\nfrom colorspace import diverging_hcl, specplot\npal = diverging_hcl(\"Purple-Green\", rev = True)\nspecplot(pal(99));"
  },
  {
    "objectID": "articles/endrainbow.html#weather-map-dewpoint-temperature",
    "href": "articles/endrainbow.html#weather-map-dewpoint-temperature",
    "title": "Somewhere over the Rainbow",
    "section": "Weather map: Dewpoint temperature",
    "text": "Weather map: Dewpoint temperature\nAnother shaded map for communicating a weather forecast is shown below, depicting dewpoint temperature forecasts from a certain FV3 Global Forecast System (GFS) product. It also does not use a standard rainbow but a palette of similarly highly-saturated colors from a wide range of hues (left panel).\nAs in the previous section, the palette is very discontinuous and breaks the values down into separate “classes” or “bands”. For experienced users this may help locating bands with very specific numeric values but leads to an uneven overall picture. In contrast, the sequential_hcl(\"ag_Sunset\").colors(23) palette (right panel) shows a smooth gradient, giving somewhat more emphasis to the darker low-temperature regions.\n\n\n\n\n\n\n\n\n\n\n\n\n\nDepicting the hue/chroma/luminance trajectories of both palettes also shows the abrupt changes in the original palette which do not convey a continuous temperature scale. Instead, the HCL-based sunset palette is also built from a wide range of hues but changes hue, chroma, and luminance smoothly.\n\nfrom colorspace import specplot\noriginal = [\"#F6C77B\", \"#A8373A\", \"#009BFF\", \"#D35252\", \"#0DD189\", \"#E3AF36\",\n            \"#9CE743\", \"#EE8130\", \"#FE9E23\", \"#E4E4E4\", \"#ACFBA4\", \"#4EF159\",\n            \"#1BA120\", \"#00DE28\", \"#92CDF8\", \"#3D8FF0\", \"#205FCD\", \"#0EC6C6\",\n            \"#BCAEFD\", \"#4D33C4\", \"#9B00C4\", \"#2829FB\", \"#F83940\"]\nspecplot(original);\n\n\n\n\n\n\n\n\n\nfrom colorspace import sequential_hcl, specplot\npal = sequential_hcl(\"ag_Sunset\").colors(23)\nspecplot(pal);\n\n\n\n\n\n\n\n\nConsequently, the figure with the sunset palette also works reasonably well in grayscale or for colorblind viewers while the original palette is rather problematic."
  },
  {
    "objectID": "articles/endrainbow.html#risk-map-influenza",
    "href": "articles/endrainbow.html#risk-map-influenza",
    "title": "Somewhere over the Rainbow",
    "section": "Risk map: Influenza",
    "text": "Risk map: Influenza\nThe shaded map below was taken from the web site of the Robert Koch-Institut (Arbeitsgemeinschaft Influenza) and it shows the severity of influenza in Germany in week 8, 2019. The original color palette (left) is the classic rainbow ranging from “normal” (blue) to “strongly increased” (red). As all colors in the palette are very flashy and highly-saturated it is hard to grasp intuitively which areas are most affected by influenza. Also, the least interesting “normal” areas stand out as blue is the darkest color in the palette.\nAs an alternative, a proper multi-hue sequential_hcl(\"Purple-Yellow\")(99) palette is used on the right. This has smooth gradients and the overall message can be grasped quickly, giving focus to the high-risk regions depicted with dark/colorful colors. However, the extremely sharp transitions between “normal” and “strongly increased” areas (e.g., in the North and the East) might indicate some overfitting in the underlying smoothing for the map.\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverting all colors to grayscale brings out even more clearly why the overall picture is so hard to grasp with the original palette: The gradients are discontinuous switching several times between bright and dark. Thus, it is hard to identify the high-risk regions while this is more natural and straightforward with the HCL-based sequential palette.\n\n\n\n\n\n\n\n\n\n\n\n\n\nEmulating deuteranope vision emphasizes the same problems as the desaturated version above but shows even more problems with the original palette.\n\n\n\n\n\n\n\n\n\n\n\n\n\nShowing changes in hue/chroma/luminance across the two palettes also highlights the discontinuity vs. smoothness of the two palettes.\n\nfrom colorspace import rainbow, specplot\npal = rainbow(end = 2/3, rev = True)\nspecplot(pal(99));\n\n\n\n\n\n\n\n\n\nfrom colorspace import sequential_hcl, specplot\npal = sequential_hcl(\"Purple-Yellow\", rev = True)\nspecplot(pal(99));"
  },
  {
    "objectID": "articles/palette_visualization.html",
    "href": "articles/palette_visualization.html",
    "title": "Palette Visualization and Assessment",
    "section": "",
    "text": "The colorspace package provides several visualization functions for depicting one or more color palettes and their underlying properties. Color palettes can be visualized by:\n\nswatchplot: Color swatches.\nspecplot: Spectrum of HCL and/or RGB trajectories.\ndemoplot: Illustrations of typical (and simplified) statistical graphics."
  },
  {
    "objectID": "articles/palette_visualization.html#overview",
    "href": "articles/palette_visualization.html#overview",
    "title": "Palette Visualization and Assessment",
    "section": "",
    "text": "The colorspace package provides several visualization functions for depicting one or more color palettes and their underlying properties. Color palettes can be visualized by:\n\nswatchplot: Color swatches.\nspecplot: Spectrum of HCL and/or RGB trajectories.\ndemoplot: Illustrations of typical (and simplified) statistical graphics."
  },
  {
    "objectID": "articles/palette_visualization.html#color-swatches",
    "href": "articles/palette_visualization.html#color-swatches",
    "title": "Palette Visualization and Assessment",
    "section": "Color swatches",
    "text": "Color swatches\nThe function swatchplot is a convenience function for displaying collections of palettes that can be specified in different ways, e.g., an object of class palette, a colorobject, or hclpalette with a single palette or a list or dictionary to display and group multiple palettes at once.\nfrom colorspace import swatchplot, sequential_hcl, palette\n\n# Creating three palettes varying in only one dimension each\nhue       = sequential_hcl(h = [0, 360], c = 60, l = 65)\nchroma    = sequential_hcl(h = 0, c = [100, 0], l = 65,\n                           rev = True, power = 1)\nluminance = sequential_hcl(h = 260, c = 25, l = [25, 90],\n                           rev = True, power = 1)\n\nswatchplot([palette(hue(5), \"Hue\"),\n            palette(chroma(5), \"Chroma\"),\n            palette(luminance(5), \"Luminance\")],\n            figsize = (5, 1.5));\n\n\n\n\n\n\n\nThis shows the following:\n\nHue: Only the hue (= type of color) changes from H = 0 (red) via 60 (yellow), etc. to 300 (purple) while chroma and luminance are fixed to moderate values of C = 60 and L = 65, respectively.\nChroma: Only the chroma (= colorfulness) changes from C = 0 (gray) to 100 (colorful) while hue and luminance are fixed to H = 0 (red) and L = 65, respectively.\nLuminance: Only the luminance (= brightness) changes from L = 90 (light) to 25 (dark) while hue and chroma are fixed to H = 260 (blue) and C = 25 (low, close to gray), respectively.\n\nNext, we demonstrate a more complex example of a swatchplot call where the object provided is a dictionary of lists where each list contains a series of 4 palettes.hclpalette object consisting of blues, purples, reds, and greens. The keys of the dictionary are used for ‘group titles’, the name of the palettes is suppressed in this case (argument show_names = False).\nFor all palettes, luminance increases monotonically to yield a proper sequential palette. However, the hue and chroma handling is somewhat different to emphasize different parts of the palette.\n\nSingle-hue: In each palette the hue is fixed and chroma decreases monotonically (along with increasing luminance). This is typically sufficient to clearly bring out the extreme colors (dark/colorful vs. light gray).\nSingle-hue (advanced): The hue is fixed (as above) but the chroma trajectory is triangular. Compared to the basic single-hue palette above, this better distinguishes the colors in the middle and not only the extremes.\nMulti-hue (advanced): As in the advanced single-hue palette, the chroma trajectory is triangular but additionally the hue varies slightly. This can further enhance the distinction of colors in the middle of the palette.\n\nfrom colorspace import swatchplot, sequential_hcl\n\nswatchplot({\"Single-hue\":           [sequential_hcl(x) for x in [\"Blues 2\", \"Purples 2\", \"Reds 2\", \"Greens 2\"]],\n           \"Single-hue (advanced)\": [sequential_hcl(x) for x in [\"Blues 3\", \"Purples 3\", \"Reds 3\", \"Greens 3\"]],\n           \"Multi-hue (advanced)\":  [sequential_hcl(x) for x in [\"Blues\", \"Purples\", \"Reds\", \"Greens\"]]},\n           n = 7, show_names = False, nrow = 5, figsize = (10, 2.5));\n\n\n\n\n\n\n\nMoreover, the cvd argument can be set to a vector of transformation names, indicating which deficiencies to emulate. In the example below this is used to compare the Viridis and YlGnBu palettes under deuteranopia and desaturation.\nfrom colorspace import sequential_hcl, palette, swatchplot\npal1 = sequential_hcl(\"YlGnBu\")(7)\npal2 = sequential_hcl(\"Viridis\")(7)\n\nswatchplot([palette(pal1, \"YlGnBu\"), palette(pal2, \"Viridis\")],\n            cvd = [\"protan\", \"desaturate\"], nrow = 4, figsize = (10, 2.5));"
  },
  {
    "objectID": "articles/palette_visualization.html#hcl-and-rgb-spectrum",
    "href": "articles/palette_visualization.html#hcl-and-rgb-spectrum",
    "title": "Palette Visualization and Assessment",
    "section": "HCL (and RGB) spectrum",
    "text": "HCL (and RGB) spectrum\nAs the properties of a palette in terms of the perceptual dimensions hue, chroma, and luminance are not always clear from looking just at color swatches or (statistical) graphics based on these palettes, the specplot function provides an explicit display for the coordinates of the HCL trajectory associated with a palette. This can bring out clearly various aspects, e.g., whether hue is constant, whether chroma is monotonic or triangular, and whether luminance is approximately constant (as in many qualitative palettes), monotonic (as in sequential palettes), or diverging.\nThe function first transforms a given color palette to its HCL (polarLUV) coordinates. As the hues for low-chroma colors are not (or only poorly) identified, they are smoothed by default. Also, to avoid jumps from 0 to 360 or vice versa, the hue coordinates are shifted suitably.\nBy default, the resulting trajectories in the HCL spectrum are visualized by a simple line plot:\n\nHue is drawn in red and coordinates are indicated on the axis on the right with range [-360, 360].\nChroma is drawn in green with coordinates on the left axis. The range [0, 100] is used unless the palette necessitates higher chroma values.\nLuminance is drawn in blue with coordinates on the left axis in the range [0, 100].\n\nAdditionally, a color swatch for the palette is included. Optionally, a second spectrum for the corresponding trajectories of RGB coordinates can be included. However, this is usually just of interest for palettes created in RGB space (or simple transformations of RGB).\nThe illustrations below show how basic qualitative, sequential, and diverging palettes are constructed in HCL space (the corresponding mathematical equations are provided in the :ref:article-hcl_palettes-section-construction-details). In the qualitative \"Set 2\" palette below, the hue traverses the entire color “wheel” (from 0 to 360 degrees) while keeping chroma and luminance (almost) constant (C = 60 and L = 70).\nfrom colorspace import specplot, qualitative_hcl\n\nspecplot(qualitative_hcl(\"Set 2\").colors(100));\n\n\n\n\n\n\n\nNote that due to the restrictions of the HCL color space, some of the green/blue colors have a slightly smaller maximum chroma resulting in a small dip in the chroma curve. This is fixed automatically (by default) and is hardly noticable in visualizations, though.\nThe sequential “Blues 2” palette below employs a single hue (H = 260) and a monotonically increasing luminance trajectory (from dark to light). Chroma simply decreases monotonically along with increasing luminance.\nfrom colorspace import specplot, sequential_hcl\n\nspecplot(sequential_hcl(\"Blues 2\").colors(100));\n\n\n\n\n\n\n\nFinally, the diverging “Blue-Red” palette is depicted below. It simply combines a blue and a red sequential single-hue palette (similar to the “Blues 2” palette discussed above). Hue is constant in each “arm” of the palette and the chroma/luminance trajectories are balanced between both arms. In the center the palette passes through a light gray (with zero chroma) as the neutral value.\nfrom colorspace import specplot, diverging_hcl\n\nspecplot(diverging_hcl(\"Blue-Red\").colors(100));\n\n\n\n\n\n\n\nTo contrast these well-balanced HCL-based palettes with a poorly-balanced palette, the spectrum of the (in)famous RGB rainbow palette is depicted in both RGB and HCL space.\nfrom colorspace import specplot, rainbow\n\nspecplot(rainbow().colors(100));"
  },
  {
    "objectID": "articles/palette_visualization.html#demonstration-of-statistical-graphics",
    "href": "articles/palette_visualization.html#demonstration-of-statistical-graphics",
    "title": "Palette Visualization and Assessment",
    "section": "Demonstration of statistical graphics",
    "text": "Demonstration of statistical graphics\nTo demonstrate how different kinds of color palettes work in different kinds of statistical displays, demoplot() provides a simple convenience interface to some base graphics with (mostly artificial) data sets. As a first overview, all built-in demos are displayed with the same sequential heat colors palette: sequential_hcl(\"Heat\")(7).\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, sequential_hcl\n\ncolors = sequential_hcl(\"Heat\").colors(5)\nfig, axes = plt.subplots(2, 4, figsize = (10, 6))\n\ndemo_types = [\"Bar\", \"Heatmap\", \"Lines\", \"Matrix\", \"Pie\", \"Spine\", \"Map\", None]\nfor i in range(0, len(demo_types)):\n    if demo_types[i] == None:\n        fig.delaxes(axes.flatten()[i])\n    else:\n        demoplot(colors, type_ = demo_types[i], title = demo_types[i], ax = axes.flatten()[i])\n\nplt.show()\n\n\n\n\n\n\n\nAll types of demos can, in principle, deal with arbitrarily many colors from any palette, but the graphics differ in various respects such as:\n\nWorking best for fewer colors (e.g., bar, pie, lines, …) vs. many colors (e.g., heatmap, …).\nIntended for categorical data (e.g., bar, pie, …) vs. continuous numeric data (e.g., heatmap, …).\nShading areas (e.g., map, bar, pie, …) vs. coloring points or lines.\n\nHence, in the following some further illustrations are organized by type of palette, using suitable demos for the particular palettes.\nQualitative palettes: Light pastel colors typically work better for shading areas (pie, left) while darker and more colorful palettes are usually preferred for lines (right).\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, qualitative_hcl\n\nfig, [ax1, ax2] = plt.subplots(1, 2, figsize = (6.5, 3))\n\nax1 = demoplot(qualitative_hcl(\"Pastel 1\"), type_ = \"Pie\",   n = 4, ax = ax1)\nax2 = demoplot(qualitative_hcl(\"Dark 3\"),   type_ = \"Lines\", n = 4, ax = ax2)\n\nplt.show()\n\n\n\n\n\n\n\nSequential palettes: Heatmaps (left) often employ almost continuous gradients with strong luminance contrasts. In contrast, when only a few ordered categories are to be displayed (e.g., in a spine plot, right) more colorful sequential palettes like the viridis palette can be useful.\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, sequential_hcl\n\nfig, [ax1, ax2] = plt.subplots(1, 2, figsize = (6.5, 3))\n\nax1 = demoplot(sequential_hcl(\"Purple-Blue\", rev = True), type_ = \"Heatmap\", n = 99, ax = ax1)\nax2 = demoplot(sequential_hcl(\"Viridis\"),                 type_ = \"Spine\",   n =  4, ax = ax2)\n\nplt.show()\n\n\n\n\n\n\n\nDiverging palettes: In some displays (such as the map, left), it is useful to employ an almost continuous gradient with strong luminance contrast to bring out the extremes. Here, this contrast is amplified by a larger power transformation emphasizing the extremes even further. In contrast, when fewer colors are needed more colorful palettes with lower luminance contrasts can be desired. This is exemplified by a mosaic (center) and bar plot (right).\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, sequential_hcl\n\nfig, [ax1, ax2, ax3] = plt.subplots(1, 3, figsize = (10, 3))\n\nax1 = demoplot(diverging_hcl(\"Tropic\", power = 2.5), type_ = \"Map\",    n = 99, ax = ax1)\nax2 = demoplot(diverging_hcl(\"Green-Orange\"),        type_ = \"Matrix\", n =  5, ax = ax2)\nax3 = demoplot(diverging_hcl(\"Blue-Red 2\"),          type_ = \"Bar\",    n =  5, ax = ax3)\n\nplt.show()\n\n\n\n\n\n\n\nAll displays above focus on palettes designed for light/white backgrounds. Therefore, to conclude, some palettes are highlighted that work well on dark/black backgrounds.\nfrom matplotlib import pyplot as plt\nfrom colorspace import demoplot, sequential_hcl, qualitative_hcl, diverging_hcl\n\nfig, axes = plt.subplots(2, 3, figsize = (10, 6))\nplt.style.use(\"dark_background\")\n\naxes[0, 0] = demoplot(sequential_hcl(\"Oslo\", rev = True),  \"Heatmap\", ax = axes[0, 0])\naxes[0, 1] = demoplot(sequential_hcl(\"Turku\", rev = True), \"Heatmap\", ax = axes[0, 1])\naxes[0, 2] = demoplot(sequential_hcl(\"Inferno\"),           \"Heatmap\", ax = axes[0, 2])\n\naxes[1, 0] = demoplot(qualitative_hcl(\"Set 2\"), \"Lines\", ax = axes[1, 0])\naxes[1, 1] = demoplot(diverging_hcl(\"Berlin\"),  \"Lines\", ax = axes[1, 1])\naxes[1, 2] = demoplot(diverging_hcl(\"Cyan-Magenta\", l2 = 20), \"Lines\", ax = axes[1, 2])\n\nplt.show()\n\nimport matplotlib as mpl\nmpl.rcParams.update(mpl.rcParamsDefault)"
  },
  {
    "objectID": "articles/manipulation_utilities.html",
    "href": "articles/manipulation_utilities.html",
    "title": "Color Manipulation and Utilities",
    "section": "",
    "text": "The colorspace package provides several color manipulation utilities that are useful for creating, assessing, or transforming color palettes, namely:\n\ndesaturate: Desaturate colors by chroma removal in HCL space.\nlighten and darken: Algorithmically lighten or darken colors in HCL and/or HLS space.\nadjust_transparency and extract_transparency to remove, adjust, and extract the transparency.\ncontrast_ratio to compute and visualize W3C contrast ratios of colors.\nmax_chroma to calculate maximum chroma for given hue and luminance in HCL space.\ncompare_colors to compare if two sets of colors are (nearly) equal."
  },
  {
    "objectID": "articles/manipulation_utilities.html#overview",
    "href": "articles/manipulation_utilities.html#overview",
    "title": "Color Manipulation and Utilities",
    "section": "",
    "text": "The colorspace package provides several color manipulation utilities that are useful for creating, assessing, or transforming color palettes, namely:\n\ndesaturate: Desaturate colors by chroma removal in HCL space.\nlighten and darken: Algorithmically lighten or darken colors in HCL and/or HLS space.\nadjust_transparency and extract_transparency to remove, adjust, and extract the transparency.\ncontrast_ratio to compute and visualize W3C contrast ratios of colors.\nmax_chroma to calculate maximum chroma for given hue and luminance in HCL space.\ncompare_colors to compare if two sets of colors are (nearly) equal."
  },
  {
    "objectID": "articles/manipulation_utilities.html#desaturation-in-hcl-space",
    "href": "articles/manipulation_utilities.html#desaturation-in-hcl-space",
    "title": "Color Manipulation and Utilities",
    "section": "Desaturation in HCL space",
    "text": "Desaturation in HCL space\nDesaturation should map a given color to the gray with the same “brightness”. In principle, any perceptually-based color model (HCL, HLS, HSV, …) could be employed for this but HCL works particularly well because its coordinates capture the perceptual properties better than most other color models.\nThe desaturate function converts any given hex color code to the corresponding HCL coordinates and sets the chroma to zero. Thus, only the luminance matters which captures the “brightness” mentioned above. Finally, the resulting HCL coordinates are transformed back to hex color codes.\nFor illustration, a few simple examples are presented below. More examples in the context of palettes for statistical graphics are discussed along with the color vision deficiency article.\n\nfrom colorspace import rainbow, desaturate, swatchplot, palette\n\n# Draw 5 colros from the infamous RGB rainbow\ncol_rainbow = rainbow()(5)\ncol_rainbow\n\n['#FF0000', '#CCFF00', '#00FF66', '#0066FF', '#CC00FF']\n\n\n\n# Desaturate the colors\ncol_desat   = desaturate(col_rainbow)\ncol_desat\n\n['#7F7F7F', '#EDEDED', '#DDDDDD', '#727272', '#7C7C7C']\n\n\n# Compare the two color palettes\nswatchplot([palette(col_rainbow, name = \"original\"),\n            palette(col_desat,   name = \"desaturated\")],\n            figsize = (8, 1.5));\n\n\n\n\n\n\n\nEven this simple example suffices to show that the three RGB rainbow colors have very different grayscale levels. This deficiency is even clearer when using a full color wheel (of colors with hues in [0, 360] degrees). While the RGB rainbow is very unbalanced the HCL rainbow_hcl (or also qualitative_hcl) is (by design) balanced with respect to luminance.\nfrom matplotlib import pyplot as plt\nfrom colorspace import rainbow, rainbow_hcl, desaturate\nfrom numpy import repeat\n\ndef wheel(ax, col): ax.pie(repeat(1, len(col)), colors = col, labels = range(len(col)))\n\ncol     = rainbow()(8)\ncol_hcl = rainbow_hcl()(8)\n\nfig, axes = plt.subplots(2, 2, figsize = (8, 8))\nwheel(axes[0, 0], col)\nwheel(axes[0, 1], desaturate(col))\nwheel(axes[1, 0], col_hcl)\nwheel(axes[1, 1], desaturate(col_hcl))\n\nfig.tight_layout()\nplt.show()"
  },
  {
    "objectID": "articles/manipulation_utilities.html#lighten-and-darken-colors",
    "href": "articles/manipulation_utilities.html#lighten-and-darken-colors",
    "title": "Color Manipulation and Utilities",
    "section": "Lighten and darken colors",
    "text": "Lighten and darken colors\nIn principle, a similar approach for lightening and darkening colors can be employed as for desaturation above. The colors can simply be transformed to HCL space and then the luminance can either be decreased (turning the color darker) or increased (turning it lighter) while preserving the hue and chroma coordinates.\nThis strategy typically works well for lightening colors, although in some situations the result can be rather colorful. Conversely, when darkening rather light colors with little chroma, this can result in rather gray colors.\nIn these situations, an alternative might be to apply the analogous strategy in HLS space which is frequently used in HTML style sheets. However, this strategy may also yield colors that are either too gray or too colorful. A compromise that sometimes works well is to adjust the luminance coordinate in HCL space but to take the chroma coordinate corresponding to the HLS transformation.\nWe have found that typically the HCL-based transformation performs best for lightening colors and this is hence the default in lighten. For darkening colors, the combined strategy often works best and is hence the default in darken. In either case it is recommended to try the other available strategies in case the default yields unexpected results.\nRegardless of the chosen color space, the adjustment of the L component can occur by two methods, relative (the default) and absolute. For example L - 100 * amount is used for absolute darkening, or L * (1 - amount) for relative darkening. See lighten and darken for more details.\nFor illustration a qualitative palette (Okabe-Ito) is transformed by two levels of both lightening and darkening, respectively.\nfrom colorspace import palette, swatchplot, lighten, darken\noi = [\"#61A9D9\", \"#ADD668\", \"#E6D152\", \"#CE6BAF\", \"#797CBA\"]\n\nswatchplot([palette(lighten(oi, 0.4), \"-40%\"),\n            palette(lighten(oi, 0.2), \"-20%\"),\n            palette(oi, \"0%\"),\n            palette(darken(oi, 0.2), \"+20%\"),\n            palette(darken(oi, 0.4), \"+40%\")],\n            figsize = (5.5, 3));"
  },
  {
    "objectID": "articles/manipulation_utilities.html#adjust-or-extract-the-transparency-of-colors",
    "href": "articles/manipulation_utilities.html#adjust-or-extract-the-transparency-of-colors",
    "title": "Color Manipulation and Utilities",
    "section": "Adjust or extract the transparency of colors",
    "text": "Adjust or extract the transparency of colors\nAlpha transparency is useful for making colors semi-transparent, e.g., for overlaying different elements in graphics. An alpha value (or alpha channel) of 0 (or 00 in hex strings) corresponds to fully transparent and an alpha value of 1 (or FF in hex strings) corresponds to fully opaque. If a color hex string does not provide an explicit alpha transparency, the color is assumed to be fully opaque.\nCurrently the package only allows to manipulate the transparency of objects inheriting from colorlib.colorobject (see Color Spaces).\nThe adjust_transparency function can be used to adjust the alpha transparency of a set of colors. It always returns a hex color specification. This hex color can have the alpha transparency added/removed/modified depending on the specification of the argument alpha. The function returns an object of the same class as provided on x with (possibly) adjusted transparency.\n\nNone: If alpha = None existing transparency will be removed (if any exists).\nConstant: In case a single float or integer (\\(\\in [0., 1.]\\)) is provided constant transparency will be added to all colors on x.\nList or numpy ndarray: If a list or numpy.ndarray is provided the length of the object must match the number of colors of the object provided on x. All elements of the list/array must be convertable to float and must be in \\(\\in [0., 1.]\\).\n\nFor illustration, the transparency of a single black color is modified to three alpha levels: fully transparent, semi-transparent, and fully opaque, respectively. Black can be equivalently specified by name (\"black\"), hex string (\"#000000\"), or integer position in the standard palette (\"0\").\nfrom colorspace.colorlib import hexcols\nfrom colorspace import adjust_transparency\n\ncols = hexcols([\"black\", \"#000000\", \"0\"])\nprint(cols)\n\n\n\nhexcols color object (3 colors)\n        hex_\n  1:b'#000000'\n    b'#000000'\n    b'#000000'\n\n\n\n\nprint(cols.colors())\n\n['#000000', '#000000', '#000000']\n\n\n\ncols = adjust_transparency(cols, [0.0, 0.5, 1.0])\nprint(cols)\n\nhexcols color object (3 colors)\n        hex_   alpha\n  1:b'#000000'    00\n    b'#000000'    7F\n    b'#000000'    FF\n\n\n\nprint(cols.colors())\n\n['#00000000', '#00000050', '#000000']\n\n\nSubsequently we can set a constant transparency for all colors by providing one single value, or remove transparency information by setting alpha = None. Given the same object as above:\nfrom colorspace import extract_transparency\n\ncols = adjust_transparency(cols, 0.8)   # Set to constant\nprint(cols)\n\n\n\nhexcols color object (3 colors)\n        hex_   alpha\n  1:b'#000000'    CC\n    b'#000000'    CC\n    b'#000000'    CC\n\n\n\n\ncols = adjust_transparency(cols, None)  # Remove transparency\nprint(cols)\n\nhexcols color object (3 colors)\n        hex_\n  1:b'#000000'\n    b'#000000'\n    b'#000000'\n\n\nThe extract_transparency function can be used to extract the alpha transparency from a set of colors. It allows to define the mode of the return value. This can either be float (\\(\\in [0., 1.]\\)), int (\\({0, 1, ..., 255}\\)), or str (\"00\", \"01\", …, \"FF\"). In case no transparency is defined at all, None will be returned.\nFor illustration we extract the transparency from the gray colors in x in different formats.\n\nfrom colorspace.colorlib import hexcols\n# Some colors with transparency 80%, 40%, 80%\nx = hexcols(['#023FA5CC', '#E2E2E266', '#8E063BCC'])\n\nextract_transparency(x, mode = \"float\")\n\narray([0.8, 0.4, 0.8])\n\n\n\nextract_transparency(x, mode = \"int\")\n\narray([204, 102, 204], dtype=int16)\n\n\n\nextract_transparency(x, mode = \"str\")\n\narray(['CC', '66', 'CC'], dtype='&lt;U2')"
  },
  {
    "objectID": "articles/manipulation_utilities.html#compute-and-visualize-w3c-contrast-ratios",
    "href": "articles/manipulation_utilities.html#compute-and-visualize-w3c-contrast-ratios",
    "title": "Color Manipulation and Utilities",
    "section": "Compute and visualize W3C contrast ratios",
    "text": "Compute and visualize W3C contrast ratios\nThe Web Content Accessibility Guidelines (WCAG) by the World Wide Web Consortium (W3C) recommend a contrast ratio of at least 4.5 for the color of regular text on the background color, and a ratio of at least 3 for large text. See . This relies on a specific definition of relative luminances (essentially based on power-transformed sRGB coordinates) that is different from the perceptual luminance as defined, for example, in the HCL color model. Note also that the WCAG pertain to text and background color and not to colors used in data visualization.\nFor illustration we compute and visualize the contrast ratios of the default palette in R compared to a white background.\n\nfrom colorspace import rainbow, contrast_ratio\ncols = rainbow().colors(7)\ncontrast_ratio(cols, \"#FFFFFF\") # Against white\n\narray([3.99847677, 1.36500073, 1.34725121, 1.33595736, 3.20339072,\n       7.69994138, 3.34666975])\n\n\n\ncontrast_ratio(cols, \"#000000\") # Against black\n\narray([ 5.252     , 15.38460716, 15.58729349, 15.71906457,  6.55555374,\n        2.72729349,  6.27489463])\n\n\nres = contrast_ratio(cols, plot = True, figsize = (3, 3))"
  },
  {
    "objectID": "articles/manipulation_utilities.html#maximum-chroma-for-given-hue-and-luminance",
    "href": "articles/manipulation_utilities.html#maximum-chroma-for-given-hue-and-luminance",
    "title": "Color Manipulation and Utilities",
    "section": "Maximum chroma for given hue and luminance",
    "text": "Maximum chroma for given hue and luminance\nAs the possible combinations of chroma and luminance in HCL space depend on hue, it is not obvious which trajectories through HCL space are possible prior to trying a specific HCL coordinate by calling polarLUV. To avoid having to fix up the color upon conversion to RGB hex color codes, the max_chroma function computes (approximately) the maximum chroma possible.\nFor illustration we show that for given luminance (here: L = 50) the maximum chroma varies substantially with hue:\n\nfrom colorspace import max_chroma\nfrom numpy import linspace\n\nmax_chroma(linspace(0, 360, 7), L = 50)\n\narray([137.96,  59.99,  69.06,  39.81,  65.45, 119.54, 137.96])\n\n\nSimilarly, maximum chroma also varies substantially across luminance values for a given hue (here: H = 120, green):\n\nfrom colorspace import max_chroma\nfrom numpy import linspace\n\nmax_chroma(H = 120, L = linspace(0, 100, 6))\n\narray([  0.  ,  28.04,  55.35,  82.79, 110.28,   0.  ])\n\n\nIn the plots below more combinations are visualized: In the left panel for maximum chroma across hues given luminance and in the right panel with increasing luminance given hue.\nfrom colorspace.colorlib import HCL\nfrom colorspace import max_chroma\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Setting up the plot\nfig, [ax1, ax2] = plt.subplots(1, 2, figsize = (9, 4))\n\n# ----------------------------------------\n# C vs. H plot\n# ----------------------------------------\nH = np.linspace(0, 360, 37, endpoint = True, dtype = \"int\")\nL = np.linspace(30, 90, 4, endpoint = True, dtype = \"int\")\n\nC = []; Cmax = 0\nfor i in range(len(L)):\n    C.append(max_chroma(H, float(L[i])))\n    Cmax = max(Cmax, max(C[i]))\n\nfor i in range(len(L)):\n    colors = HCL(H, C[i], np.repeat(L[i], len(H))).colors()\n    ax1.plot(H, C[i], color = \"0.5\", zorder = 1)\n    ax1.scatter(H, C[i], c = colors, zorder = 2)\n\nax1.set_xlim(0, 360)\nax1.set_ylim(0, Cmax * 1.05)\nyr = ax1.secondary_yaxis(\"right\")\nyr.set_ticks([x[len(x) - 1] for x in C])\nyr.set_yticklabels([\"L = {:d}\".format(x) for x in L])\nax1.set_xlabel(\"Hue (H)\")\nax1.set_ylabel(\"Maximum chroma (C)\")\n\n\n# ----------------------------------------\n# L vs. C plot\n# ----------------------------------------\nL = np.linspace(0, 100, 21, endpoint = True, dtype = \"int\")\nH = np.asarray([0, 60, 120, 250, 330], dtype = \"int\")\n\nC = []; Cmax = 0\nfor i in range(len(H)):\n    C.append(max_chroma(float(H[i]), L))\n    Cmax = max(Cmax, max(C[i]))\n\nfor i in range(len(H)):\n    colors = HCL(np.repeat(H[i], len(L)), C[i], L).colors()\n    ax2.plot(C[i], L, color = \"0.5\", zorder = 1)\n    ax2.scatter(C[i], L, c = colors, zorder = 2)\n    # Setting label\n    idx = int(np.where(C[i] == max(C[i]))[0][0])\n    ax2.text(C[i][idx] + Cmax / 15, L[idx], \"H = {:d}\".format(H[i]),\n             color = colors[idx], va = \"center\")\n\nax2.set_xlim(0, Cmax * 1.20)\nax2.set_ylim(0, 100)\nax2.set_xlabel(\"Maximum chroma (C)\")\nax2.set_ylabel(\"Luminance (L)\")\n\n# Display result\nfig.tight_layout()\nplt.show()"
  },
  {
    "objectID": "articles/hcl_palettes.html",
    "href": "articles/hcl_palettes.html",
    "title": "HCL-Based Color Palettes",
    "section": "",
    "text": "As motivated in the previous article (Color Spaces: Classes and Methods), the HCL space is particularly useful for specifying individual colors and color palettes, as its three axes match those of the human visual system very well. Therefore, the colorspace package provides three types of palettes based on the HCL model:\nThe corresponding classes are qualitative_hcl, sequential_hcl, and diverging_hcl. Their construction principles are exemplified in the following color swatches and explained in more detail below. The desaturated palettes bring out clearly that luminance differences (light-dark contrasts) are crucial for sequential and diverging palettes while qualitative palettes are balanced at the same luminance.\nMore details about the construction of such palettes is provided in the following while the article on Palette Visualization and Assessment introduces further tools to better understand the properties of color palettes.\nTo facilitate obtaining good sets of colors, HCL parameter combinations that yield useful palettes are accessible by name. These can be listed using the function hcl_palettes.\nfrom colorspace import hcl_palettes\nhcl_palettes()\n\nHCL palettes\n\nType:  Basic: Sequential (single-hue)\nNames: Grays, Light Grays, Blues 2, Purples 2, Reds 2\n       Greens 2\n\nType:  Basic: Sequential (multi-hue)\nNames: Purple-Blue, Red-Purple, Red-Blue, Purple-Orange\n       Blue-Yellow, Green-Yellow, Red-Yellow, Heat, Heat 2\n       Terrain, Terrain 2, Viridis, Plasma, Dark Mint, Mint\n       Emrld, BluYl, ag_GrnYl, Peach, PinkYl\n\nType:  Basic: Qualitative\nNames: Pastel 1, Dark 2, Dark 3, Set 2, Set 3, Warm, Cold\n       Harmonic, Dynamic\n\nType:  Basic: Diverging\nNames: Blue-Red, Blue-Red 2, Blue-Yellow 2, Blue-Yellow 3\n       Green-Orange, Cyan-Magenta, Tropic\n\nType:  Advanced: Sequential (single-hue)\nNames: Blues 3, Purples 3, Reds 3, Greens 3, Oslo\n\nType:  Advanced: Sequential (multi-hue)\nNames: Purple-Yellow, Inferno, Rocket, Mako, BluGrn, Teal\n       TealGrn, Burg, BurgYl, RedOr, OrYel, Purp, PurpOr\n       Sunset, Magenta, SunsetDark, ag_Sunset, BrwnYl, YlOrRd\n       YlOrBr, OrRd, Oranges, YlGn, YlGnBu, Reds, RdPu, PuRd\n       Purples, PuBuGn, PuBu, Greens, BuGn, GnBu, BuPu, Blues\n       Lajolla, Turku, Hawaii, Batlow\n\nType:  Advanced: Diverging\nNames: Blue-Red 3, Red-Green, Purple-Green, Purple-Brown\n       Green-Brown, Blue-Yellow 2, Blue-Yellow 3, Broc, Cork\n       Vik, Berlin, Lisbon, Tofino\nTo inspect the HCL parameter combinations for a specific palette simply include the palette name where upper- vs. lower-case, spaces, etc. are ignored for matching the label, e.g., \"set2\" matches \"Set 2\" as well as \"SET2\" will.\nfrom colorspace import hcl_palettes\npal = hcl_palettes().get_palette(name = \"SET2\")\npal\n\nPalette Name: Set 2\n        Type: Basic: Qualitative\n        Inspired by: ...\n         c1            60\n         fixup       True\n         gui            1\n         h1             0\n         h2           360\n         l1            70\npal.get_settings()\n\n{'desc': '...',\n 'h1': 0,\n 'h2': 360,\n 'c1': 60,\n 'l1': 70,\n 'fixup': True,\n 'gui': 1}\nCalling qualitative_hcl, sequential_hcl, and diverging_hcl respectively, will initialize an object of class hclpalette defined by a series of parameters which specify the color palette. All parameters can either be specified “by hand” through the HCL parameters, an entire palette can be specified “by name”, or the name-based specification can be modified by a few HCL parameters. In case of the HCL parameters, either a vector-based specification such as h = [0, 270] or individual parameters h1 = 0 and h2 = 270 can be used.\nTo compute the actual color hex codes (representing sRGB coordinates), the method .colors() is used to return a list of n colors along the coordinates defined by parameters specified when constructing the object.\nThe first three of the following commands lead to equivalent output. The fourth command yields a modified set of colors (lighter due to a luminance of 80 instead of 70).\nfrom colorspace import qualitative_hcl\nqualitative_hcl()(4)\n\n['#E16A86', '#909800', '#00AD9A', '#9183E6']\nqualitative_hcl(h = [0, 270])(4)\n\n['#E16A86', '#909800', '#00AD9A', '#9183E6']\nqualitative_hcl(h1 = 0, h2 = 270, c1 = 80, l1 = 60)(4)\n\n['#E16A86', '#909800', '#00AD9A', '#9183E6']\nqualitative_hcl(l = 80).colors(4)\n\n['#FFA2BC', '#C6CE3E', '#00E4D0', '#C7BAFF']"
  },
  {
    "objectID": "articles/hcl_palettes.html#qualitative-palettes",
    "href": "articles/hcl_palettes.html#qualitative-palettes",
    "title": "HCL-Based Color Palettes",
    "section": "Qualitative palettes",
    "text": "Qualitative palettes\nqualitative_hcl distinguishes the underlying categories by a sequence of hues while keeping both chroma and luminance constant, to give each color in the resulting palette the same perceptual weight. Thus, h should be a pair of hues (or equivalently h1 and h2 can be used) with the starting and ending hue of the palette. Then, an equidistant sequence between these hues is employed, by default spanning the full color wheel (i.e., the full 360 degrees). Chroma c (or equivalently c1) and luminance l (or equivalently l1) are constants. Finally, fixup indicates whether colors with out-of-range coordinates should be corrected.\nIn the following graphic the available named palettes are shown. The first five palettes are close to the ColorBrewer.org palettes of the same name (Harrower and Brewer 2003). They employ different levels of chroma and luminance and, by default, span the full hue range. The remaining four palettes are taken from Ihaka (2003). They are based on the same chroma (50) and luminance (70) but the hue is restricted to different intervals.\nfrom colorspace import hcl_palettes\nhcl_palettes(5, \"Qualitative\", plot = True, ncol = 1, figsize = (8, 4))\n\n\n\n\n\n\n\nWhen palettes are employed for shading areas in statistical displays (e.g., in bar plots, pie charts, or regions in maps), lighter colors (with moderate chroma and high luminance) such as “Pastel 1” or “Set 3” are typically less distracting. By contrast, when coloring points or lines, more flashy colors (with high chroma) are often required: On a white background a moderate luminance as in “Dark 2” or “Dark 3” usually works better while on a black/dark background the luminance should be higher as in “Set 2” for example."
  },
  {
    "objectID": "articles/hcl_palettes.html#sequential-palettes-single-hue",
    "href": "articles/hcl_palettes.html#sequential-palettes-single-hue",
    "title": "HCL-Based Color Palettes",
    "section": "Sequential palettes (single-hue)",
    "text": "Sequential palettes (single-hue)\nsequential_hcl codes the underlying numeric values by a monotonic sequence of increasing (or decreasing) luminance. Thus, the function’s l argument should provide a vector of length \\(2\\) with starting and ending luminance (equivalently, l1 and l2 can be used). Without chroma (i.e., c = 0), this simply corresponds to a gray-scale palette, see “Grays” and “Light Grays” below.\nfrom colorspace import hcl_palettes\nhcl_palettes(7, \"Sequential (single-hue)\", plot = True,\n             ncol = 1, figsize = (8, 5))\n\n\n\n\n\n\n\nAll except the last are inspired by the ColorBrewer.org palettes with the same base name (Harrower and Brewer 2003) but restricted to a single hue only. They are intended for a white/light background. The last palette (Oslo) is taken from the scientific color maps of Crameri (2018) and is intended for a black/dark background and hence the order is reversed starting from a light blue (not a light gray).\nTo distinguish many colors in a sequential palette it is important to have a strong contrast on the luminance axis, possibly enhanced by an accompanying pronounced variation in chroma. When only a few colors are needed (e.g., for coding an ordinal categorical variable with few levels) then a lower luminance contrast may suffice."
  },
  {
    "objectID": "articles/hcl_palettes.html#sequential-palettes-multi-hue",
    "href": "articles/hcl_palettes.html#sequential-palettes-multi-hue",
    "title": "HCL-Based Color Palettes",
    "section": "Sequential palettes (multi-hue)",
    "text": "Sequential palettes (multi-hue)\nTo not only bring out extreme colors in a sequential palette but also better distinguish middle colors it is a common strategy to employ a sequence of hues. Thus, the basis of such a palette is still a monotonic luminance sequence as above (combined with a monotonic or triangular chroma sequence). But rather than using a single hue, an interval of hues in h (or beginning hue h1 and ending hue h2) can be specified.\nsequential_hcl allows combined variations in hue (h and h1/h2, respectively), chroma (c and c1/c2/cmax, respectively), luminance (l and l1/l2, respectively), and power transformations for the chroma and luminance trajectories (power and p1/p2, respectively). This yields a broad variety of sequential palettes, including many that closely match other well-known color palettes. The plot below shows all the named multi-hue sequential palettes in colorspace which consist of various palettes created during the development of colorspace, e.g., by Zeileis, Hornik, and Murrell (2009) or Stauffer et al. (2015) among others.\nIn addition palettes are provided which closely match the palettes developed by Smith and Van der Walt (2015) for matplotlib, matching CARTO palettes (CARTO 2019), ColorBrewer.org palettes (Harrower and Brewer 2003), and palettes closely matching the scientific palettes by Crameri (2018).\nhcl_palettes(7, \"Sequential (multi-hue)\", plot = True,\n             ncol = 3, figsize = (10, 8))\n\n\n\n\n\n\n\nNote that the palettes differ substantially in the amount of chroma and luminance contrasts. For example, many palettes go from a dark high-chroma color to a neutral low-chroma color (e.g., “Reds”, “Purples”, “Greens”, “Blues”) or even light gray (e.g., “Purple-Blue”). But some palettes also employ relatively high chroma throughout the palette (e.g., the viridis and many CARTO palettes). To emphasize the extremes the former strategy is typically more suitable while the latter works better if all values along the sequence should receive some more perceptual weight."
  },
  {
    "objectID": "articles/hcl_palettes.html#diverging-palettes",
    "href": "articles/hcl_palettes.html#diverging-palettes",
    "title": "HCL-Based Color Palettes",
    "section": "Diverging palettes",
    "text": "Diverging palettes\ndiverging_hcl codes the underlying numeric values by a triangular luminance sequence with different hues in the left and in the right “arms” of the palette. Thus, it can be seen as a combination of two sequential palettes with some restrictions: (a) a single hue is used for each arm of the palette, (b) chroma and luminance trajectory are balanced between the two arms, (c) the neutral central value has zero chroma. To specify such a palette a vector of two hues h (or equivalently h1 and h2), either a single chroma value c (or c1) or a vector of two chroma values c (or c1 and cmax), a vector of two luminances l (or l1 and l2), and power parameter(s) power (or p1 and p2) are used. For more flexible diverging palettes without the restrictions above (and consequently more parameters) see the divergingx_hcl palettes introduced below.\nThe plot below shows all such diverging palettes that have been named in colorspace available via the diverging_hcl class.\nA series of these palettes have been developed for the R colorspace starting from Zeileis, Hornik, and Murrell (2009), taking inspiration from various other palettes, including more balanced and simplified versions of several ColorBrewer.org palettes (Harrower and Brewer 2003) “Tropic” closely matches the palette of the same name from CARTO (CARTO 2019), “Broc” to “Vik” and “Berlin” to “Tofino” closely match the scientific color maps of the same name by Crameri (2018), where the first three are intended for a white/light background and the other three for a black/dark background.\nhcl_palettes(7, \"Diverging\", plot = True,\n             ncol = 1, figsize = (8, 10))\n\n\n\n\n\n\n\nWhen choosing a particular palette for a display similar considerations apply as for the sequential palettes. Thus, large luminance differences are important when many colors are used while smaller luminance contrasts may suffice for palettes with fewer colors etc."
  },
  {
    "objectID": "articles/hcl_palettes.html#construction-details",
    "href": "articles/hcl_palettes.html#construction-details",
    "title": "HCL-Based Color Palettes",
    "section": "Construction details",
    "text": "Construction details\nThe three different types of palettes (qualitative, sequential, and diverging) are all constructed by combining three different types of trajectories (constant, linear, triangular) for the three different coordinates (hue H, chroma C, luminance L):\n\n\n\n\n\n\n\n\n\nType\nH\nC\nL\n\n\nQualitative\nLinear\nConstant\nConstant\n\n\nSequential\n\nConstant (single-hue)\nor Linear (multi-hue)\nLinear (+ power)\nor Triangular (+ power)\nLinear (+ power)\n\n\n\nDiverging\n\nConstant (2x)\n\nLinear (+ power)\nor Triangular (+ power)\nLinear (+ power)\n\n\n\n\nAs pointed out initially in this article, luminance is probably the most important property for defining the type of palette. It is constant for qualitative palettes, monotonic for sequential palettes (linear or a power transformation), and uses two monotonic trajectories (linear or a power transformation) diverging from the same neutral value.\nHue trajectories are also rather intuitive and straightforward for the three different types of palettes. However, chroma trajectories are probably the most complicated and least obvious from the examples above. Hence, the exact mathematical equations underlying the chroma trajectories are given in the following (i.e., using the parameters c1, c2, cmax, and p1, respectively). Analogous equations apply for the other two coordinates.\nThe trajectories are functions of the intensity \\(i \\in [0,1]\\) where \\(1\\) corresponds to the full intensity:\n\\[\\begin{gather*}\n\\text{Constant}: c_1 \\\\\n\n\\text{Linear}: c_2 - (c_2 - c_1) \\times i \\\\\n\n\\text{Triangular}: \\begin{cases}\n        c_2 - (c_2 - c_{max}) \\times \\frac{i}{j}  & \\text{if}~~~~i \\le j \\\\\n        c_{max} - (c_{max} - c_1) \\times \\frac{i - j}{1 - j} & \\text{else}\n\\end{cases}\n\\end{gather*}\\]\nwhere \\(j\\) is the intensity at which \\(c_{max}\\) is assumed. It is constructed such that the slope to the left is the negative of the slope to the right of \\(j\\):\n\\[\\begin{gather*}\nj = \\Big(1 + \\frac{|c_{max} - c_1|}{|c_{max} - c_2|}\\Big)^{-1}\n\\end{gather*}\\]\nInstead of using a linear intensity \\(i\\) going from \\(1\\) to \\(0\\), one can replace \\(i\\) with \\(i ^{p_1}\\) in the equations above. This then leads to power-transformed curves that add or remove chroma more slowly or more quickly depending on whether the power parameter \\(p_1\\) is \\(&lt; 1\\) or \\(&gt; 1\\).\nThe three types of trajectories are also depicted below. Note that full intensity \\(i = 1\\) is on the left and zero intensity \\(i = 0\\) is on the right of each panel.\n\n\n\n\n\n\n\n\n\n\nThe concrete parameters in the plot above are:\n\nConstant: c1 = 80.\nLinear: c1 = 80, c2 = 10, p1 = 1 (solid) vs. p1 = 1.6 (dashed).\nTriangular: c1 = 60, cmax = 80, c2 = 10, p1 = 1 (solid) vs. p1 = 1.6 (dashed).\n\nFurther discussion of these trajectories and how they can be visualized and assessed for a given color palette is provided in the article Palette Visualization and Assessment."
  },
  {
    "objectID": "articles/hcl_palettes.html#flexible-diverging-palettes",
    "href": "articles/hcl_palettes.html#flexible-diverging-palettes",
    "title": "HCL-Based Color Palettes",
    "section": "Flexible diverging palettes",
    "text": "Flexible diverging palettes\nThe divergingx_hcl class provides more flexible diverging palettes by simply calling sequential_hcl twice with prespecified sets of hue, chroma, and luminance parameters. Thus, it does not pose any restrictions that the two “arms” of the palette need to be balanced and also may go through a non-gray neutral color (typically light yellow). Consequently, the chroma/luminance paths can be rather unbalanced.\nThe plot below shows all such flexible diverging palettes that have been named in colorspace:\n\n“ArmyRose” to “Tropic” closely match the palettes of the same name from CARTO (CARTO 2019).\n“PuOr” to “Spectral” closely match the palettes of the same name from ColorBrewer.org (Harrower and Brewer 2003).\n“Zissou 1” closely matches the palette of the same name from wesanderson (Ram and Wickham 2023).\n“Cividis” closely matches the palette of the same name from the viridis family (Garnier 2024). Note that despite having two “arms” with blue vs. yellow colors and a low-chroma center color, this is probably better classified as a sequential palette due to the monotonic chroma going from dark to light. (See Approximating Palettes from Other Packages for more details.)\n“Roma” closely matches the palette of the same name by Crameri (2018).\n\n\nfrom colorspace import divergingx_palettes\ndivergingx_palettes(n = 11, ncol = 1, plot = True, figsize = (8, 8))\n\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: divide by zero encountered in divide\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: invalid value encountered in divide\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n/opt/hostedtoolcache/Python/3.11.9/x64/lib/python3.11/site-packages/colorspace-0.4.3-py3.11.egg/colorspace/palettes.py:1083: RuntimeWarning: invalid value encountered in multiply\n  cmax - (cmax - c1) * abs((i - j) / (1 - j)))\n\n\n\n\n\n\n\n\n\nTypically, the more restricted diverging_hcl palettes should be preferred because they are more balanced. However, by being able to go through light yellow as the neutral color warmer diverging palettes are available."
  },
  {
    "objectID": "getstarted.html",
    "href": "getstarted.html",
    "title": "colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "",
    "text": "The colorspace package provides a broad toolbox for selecting individual colors or color palettes, manipulating colors, and employing them in various kinds of visualizations.\nAt the core of the package is a class which allows to draw and transform colors in different color spaces (as the package name conveys). Thus, the package helps to map various three-dimensional representations of color to each other. A particularly important mapping is the one from the perceptually-based and device-independent color model HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color specifications in many systems based on the corresponding hex codes (e.g., in HTML but also in R). For completeness further standard color models are included as well in the package: polarLUV (=HCL), CIELUV, polarLAB, CIELAB, CIEXYZ, RGB, sRGB, HLS, HSV.\nThe HCL space (= polar coordinates in CIELUV) is particularly useful for specifying individual colors and color palettes as its three axes match those of the human visual system very well: Hue (= type of color, dominant wavelength), chroma (= colorfulness), luminance (= brightness).\nfrom colorspace import palette, sequential_hcl, swatchplot\n\nH = palette(sequential_hcl(h = [0, 300], c = 60, l = 65).colors(5), \"Hue\")\nC = palette(sequential_hcl(h = 0, c = [0, 100], l = 65).colors(5), \"Chroma\")\nL = palette(sequential_hcl(h = 0, c = 0, l = [90, 25]).colors(5), \"Luminance\")\n\nswatchplot([H, C, L], figsize = (5, 1.5));\nThe colorspace package provides three types of palettes based on the HCL model:\nTo aid choice and application of these palettes there are: scales for use with matplotlib and an app for interactive exploration; visualizations of palette properties; accompanying manipulation utilities (like desaturation, lighten/darken, and emulation of color vision deficiencies).\nMore detailed overviews and examples are provided in the articles:"
  },
  {
    "objectID": "getstarted.html#installation",
    "href": "getstarted.html#installation",
    "title": "colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "Installation",
    "text": "Installation\nThe latest release candidate of this package is available via the Python Package Index (PyPI) (see https://pypi.org/project/colorspace/) as well as on GitHub.\nInstall via pip\nThe installation of the latest release can be done using pip. Will automatically install the necessary requirement (numpy). To use the full functionality of the package, matplotlib and imageio will be needed to be installed, tough not only required for visualization and CVD emulation. Check out the Installation page for more details.\npip install colorspace\n# pip install matplotlib\n# pip install imageio"
  },
  {
    "objectID": "getstarted.html#choosing-hcl-based-color-palettes",
    "href": "getstarted.html#choosing-hcl-based-color-palettes",
    "title": "colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "Choosing HCL-based color palettes",
    "text": "Choosing HCL-based color palettes\nThe colorspace package ships with a wide range of predefined color palettes, specified through suitable trajectories in the HCL (Hue-Chroma-Luminance) color space. A quick overview can be gained easily with the hcl_palettes function:\n\nfrom colorspace import hcl_palettes\nhcl_palettes(plot = True, figsize = (15, 10));\n\n\n\n\n\n\n\n\nA suitable palette object can be easily computed by specifying the desired palette name (see the plot above), e.g.,\n\nfrom colorspace import qualitative_hcl\npal = qualitative_hcl(\"Dark 3\")\npal(4)  # Draw list of 4 colors across the palette\n\n['#E16A86', '#50A315', '#009ADE', '#E16A86']\n\n\nThe functions sequential_hcland diverging_hcl work analogously. Additionally, their hue/chroma/luminance parameters can be modified, thus allowing for easy customization of each palette. Moreover, choose_palette provides a convenient user interfaces to perform palette customization interactively. Finally, even more flexible diverging HCL palettes are provided by divergingx_hcl."
  },
  {
    "objectID": "getstarted.html#palette-visualization-and-assessment",
    "href": "getstarted.html#palette-visualization-and-assessment",
    "title": "colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes",
    "section": "Palette visualization and assessment",
    "text": "Palette visualization and assessment\nThe colorspace package also provides a number of functions that aid visualization and assessment of its palettes. The demoplot function provides a series of generic/basic plot types as used by the interactive interface (choose_palette which can also be used in-line to test color palettes. In addition, specplot allows to visualize and graphically assess the spectrum of a series of colors in the RGB and HCL spectrum.\n\nfrom colorspace import diverging_hcl, demoplot\npal = diverging_hcl(\"Purple-Green\")\ndemoplot(pal(11), \"Bar\");\n\n\n\n\n\n\n\n\n\nfrom colorspace import diverging_hcl, specplot\npal = diverging_hcl(\"Purple-Green\")\nspecplot(pal(100), hcl = True, palette = True, rgb = True);"
  }
]